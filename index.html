<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Pingeus</title>
    <link rel="icon" type="image/png" href="https://pingeus.loiyaa.com/assets/favicon.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Luckiest+Guy&display=swap');

        body {
            font-family: 'Luckiest Guy', Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #2c3e50;
            color: white;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100vw;
            height: 100vh;
            box-sizing: border-box;
            overscroll-behavior: none;
            -webkit-user-select: none;
            user-select: none;
            position: relative;
        }

        #terrainCanvas {
            background-color: #87CEEB;
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            display: block;
            touch-action: none;
            position: absolute;
            z-index: 100;
        }
    </style>
</head>

<body>
    <canvas id="terrainCanvas" width="800" height="1200"></canvas>

    <script>
        const canvas = document.getElementById('terrainCanvas');
        const ctx = canvas.getContext('2d');

        const BASE_URL = 'https://pingeus.loiyaa.com/assets/';

        const collisionCanvas = document.createElement('canvas');
        collisionCanvas.width = canvas.width;
        collisionCanvas.height = canvas.height;
        const collisionCtx = collisionCanvas.getContext('2d', { willReadFrequently: true });

        // Full-resolution collision cache
        let collisionPixelCache = null;

        function updateCollisionCache() {
            const imageData = collisionCtx.getImageData(0, 0, canvas.width, canvas.height);
            collisionPixelCache = new Uint8ClampedArray(imageData.data);
        }

        function updateCollisionCacheRegion(x, y, width, height) {
            x = Math.max(0, Math.floor(x));
            y = Math.max(0, Math.floor(y));
            width = Math.min(canvas.width - x, Math.ceil(width));
            height = Math.min(canvas.height - y, Math.ceil(height));

            if (width <= 0 || height <= 0) return;

            const imageData = collisionCtx.getImageData(x, y, width, height);

            for (let py = 0; py < height; py++) {
                for (let px = 0; px < width; px++) {
                    const srcIdx = (py * width + px) * 4;
                    const destIdx = ((y + py) * canvas.width + (x + px)) * 4;

                    collisionPixelCache[destIdx] = imageData.data[srcIdx];
                    collisionPixelCache[destIdx + 1] = imageData.data[srcIdx + 1];
                    collisionPixelCache[destIdx + 2] = imageData.data[srcIdx + 2];
                    collisionPixelCache[destIdx + 3] = imageData.data[srcIdx + 3];
                }
            }
        }

        function isSolidPixelCached(x, y) {
            x = Math.floor(x);
            y = Math.floor(y);

            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return true;
            }

            const idx = (y * canvas.width + x) * 4;
            return collisionPixelCache[idx + 3] > 128;
        }

        function isBlueRampCached(x, y) {
            x = Math.floor(x);
            y = Math.floor(y);

            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return false;
            }

            const idx = (y * canvas.width + x) * 4;
            return Math.abs(collisionPixelCache[idx] - 0) <= 10 &&
                Math.abs(collisionPixelCache[idx + 1] - 102) <= 10 &&
                Math.abs(collisionPixelCache[idx + 2] - 255) <= 10 &&
                collisionPixelCache[idx + 3] > 128;
        }

        function isPurpleWallCached(x, y) {
            x = Math.floor(x);
            y = Math.floor(y);

            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return false;
            }

            const idx = (y * canvas.width + x) * 4;
            return Math.abs(collisionPixelCache[idx] - 170) <= 10 &&
                Math.abs(collisionPixelCache[idx + 1] - 68) <= 10 &&
                Math.abs(collisionPixelCache[idx + 2] - 255) <= 10 &&
                collisionPixelCache[idx + 3] > 128;
        }

        function isSolidIgnoringBlueRampsCached(x, y) {
            if (!isSolidPixelCached(x, y)) return false;
            if (isBlueRampCached(x, y)) return false;
            return true;
        }

        // Keep old functions for initialization only
        function isSolidPixel(x, y) {
            x = Math.floor(x);
            y = Math.floor(y);

            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return true;
            }

            const imageData = collisionCtx.getImageData(x, y, 1, 1);
            const data = imageData.data;
            return data[3] > 128;
        }

        const terrainCanvas = document.createElement('canvas');
        terrainCanvas.width = canvas.width;
        terrainCanvas.height = canvas.height;
        const terrainCtx = terrainCanvas.getContext('2d');

        // Testing constant - set to 1 for production
        const STARTING_LEVEL = 5;

        // UI Zone - bottom 10% reserved for buttons
        const UI_ZONE_PERCENT = 0.1;
        const UI_ZONE_Y = canvas.height * (1 - UI_ZONE_PERCENT);

        let numPoints = 45;
        let terrainRatio = 0.4;
        let points = [];
        let entrance = null;
        let exit = null;
        let lemmings = [];
        let lastSpawnTime = 0;
        const SPAWN_INTERVAL = 2000;
        let maxLemmings = 40;
        let lemmingsSpawned = 0;
        let lemmingsSaved = 0;

        let mana = 2000;
        let lastLevelBonus = 2000;
        let score = 0;

        let levelTime = 240000;
        let gameStartTime = 0;
        let currentLevel = STARTING_LEVEL;
        let gameActive = true;
        let accumulatedTime = 0;
        let gameState = 'start';
        let levelCompleteBonus = 0;
        let currentHint = '';

        // Mana orb state
        let manaOrb = null;
        let manaOrbScale = 1;
        let manaTextAnimations = [];

        // Nappy penguin state
        let nappyPenguin = null;
        let nappyPenguinScale = 1;
        let penguinCountTextAnimations = [];

        // Ice slick state
        let iceSlick = null;

        // Metal box state
        let metalBox = null;

        const gameHints = [
            "Ending a level gives you mana. Earlier levels give more mana.",
            "Penguins laugh at gravity. No matter how high the fall.",
            "Each saved penguin is +1 point. Do your best to save them all!",
            "Red and purple spells cost 40 mana. Blue uses mana per length.",
            "Blue spells are mana efficient. Keep red and purple for emergencies.",
            "The journey is endless. Save at least 1 penguin to go on."
        ];

        let gameSpeed = 1;
        let speedButton = {
            width: 120,
            height: 80,
            pressed: false,
            animationFrame: 0,
            get x() { return canvas.width - this.width - 40; },
            get y() { return canvas.height - this.height - 30; }
        };

        let currentSpell = 'blue';
        const buttonRadius = 48;
        const buttonSpacing = 140;
        const bottomY = canvas.height - 70;

        let spellButtons = [
            { spell: 'red', x: 260, y: bottomY, radius: buttonRadius, color: '#FF4444', name: 'Bomb', flashState: 0, flashStartTime: 0, showingCost: false, costStartTime: 0, shakeOffset: 0 },
            { spell: 'blue', x: 260 + buttonSpacing, y: bottomY, radius: buttonRadius, color: '#0066FF', name: 'Ramp', flashState: 0, flashStartTime: 0, showingCost: false, costStartTime: 0, shakeOffset: 0 },
            { spell: 'purple', x: 260 + buttonSpacing * 2, y: bottomY, radius: buttonRadius, color: '#AA44FF', name: 'Wall', flashState: 0, flashStartTime: 0, showingCost: false, costStartTime: 0, shakeOffset: 0 }
        ];

        let isDrawing = false;
        let drawStart = null;
        let drawCurrent = null;
        let drawnLines = [];
        let bobbingPenguins = [];
        let particles = [];
        let intermissionParticles = [];
        let foamParticles = [];

        let fishes = [];
        let lastFishSpawn = 0;
        const FISH_SPAWN_INTERVAL = 10000; // 10 seconds
        let fishEatenThisLevel = 0;
        const MAX_FISH_PER_LEVEL = 4;

        let blowfish = null;
        let blowfishSpawnTime = 0;
        let blowfishHasSpawned = false;

        let scoreAnimation = { active: false, scale: 1, startTime: 0 };
        let manaAnimation = { active: false, shake: 0, startTime: 0 };

        let seaWaveOffset = 0;
        let shipRotation = 0;
        let shipBobOffset = 0;
        let iglooScale = 1;
        let exitScale = 1;

        let startScreenPenguins = [];
        let lastStartPenguinSpawn = 0;
        const START_PENGUIN_INTERVAL = 2000;
        let startButton = {
            x: 0,
            y: 0,
            width: 300,
            height: 80,
            visible: true
        };

        let helpButton = {
            x: 0,
            y: 0,
            width: 225,
            height: 60,
            visible: true
        };

        let helpPopup = {
            visible: false,
            okButton: {
                x: 0,
                y: 0,
                width: 200,
                height: 60
            }
        };

        let intermissionButton = {
            x: 0,
            y: 0,
            width: 400,
            height: 80,
            visible: false
        };

        let gameOverButton = {
            x: 0,
            y: 0,
            width: 300,
            height: 80,
            visible: false
        };

        let jumpingPudgies = [];

        let groundPattern = null;
        let currentGroundTexture = 1;
        let currentOutlineColor = '#00AA00';
        let currentSkyColor = '#87CEEB';

        const TOTAL_TRACKS = 20;
        let musicPlaylist = [];
        let currentTrackIndex = 0;
        let currentAudio = null;
        let nextAudio = null;
        let musicEnabled = true;
        let isMusicMuted = false;
        let nextTrackPreloadTimer = null;

        // ===== HELPER FUNCTIONS =====

        // Helper: Draw text with stroke and fill
        function drawStrokedText(text, x, y, fillColor = '#FFFFFF', strokeColor = '#000000', strokeWidth = 3) {
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = strokeWidth;
            ctx.fillStyle = fillColor;
            ctx.strokeText(text, x, y);
            ctx.fillText(text, x, y);
        }

        // Helper: Calculate sine wave position for swimming entities
        function calculateSineWaveY(centerY, amplitude, phase) {
            return centerY + Math.sin(phase) * amplitude;
        }

        // Helper: Check collision between entity and lemming
        function checkEntityLemmingCollision(entityX, entityY, collisionWidth, collisionHeight, lemming) {
            if (!lemming.alive) return false;

            const halfCollisionWidth = collisionWidth / 2;
            const halfCollisionHeight = collisionHeight / 2;
            const lemmingCenterX = lemming.x + lemming.width / 2;
            const lemmingCenterY = lemming.y + lemming.height / 2;

            return Math.abs(lemmingCenterX - entityX) < halfCollisionWidth &&
                Math.abs(lemmingCenterY - entityY) < halfCollisionHeight;
        }

        // Helper: Update sine wave swimming entity
        function updateSineWaveMovement(entity, deltaTime, gameSpeed) {
            const dt = deltaTime / 1000;

            // Update horizontal speed based on game speed
            entity.vx = entity.baseVx * gameSpeed;
            entity.waveSpeed = entity.baseWaveSpeed * gameSpeed;

            // Horizontal movement
            entity.x += entity.vx * dt;

            // Sine wave vertical movement
            entity.wavePhase += entity.waveSpeed * deltaTime;
            entity.y = calculateSineWaveY(entity.centerY, entity.waveAmplitude, entity.wavePhase);
        }

        function showSpellCost(spell, cost) {
            const button = spellButtons.find(b => b.spell === spell);
            if (button) {
                button.showingCost = true;
                button.costStartTime = Date.now();
                button.lastCost = cost;
            }
        }

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        function initMusicPlaylist() {
            const tracks = Array.from({ length: TOTAL_TRACKS }, (_, i) => i + 1);
            musicPlaylist = shuffleArray(tracks);
        }

        function formatTrackNumber(num) {
            return num.toString().padStart(2, '0');
        }

        function loadTrack(trackNumber) {
            const audio = new Audio();
            const trackNum = formatTrackNumber(trackNumber);
            audio.src = BASE_URL + `track_${trackNum}.mp3`;
            audio.preload = 'auto';
            return audio;
        }

        function playNextTrack() {
            if (!musicEnabled) return;

            currentTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
            const trackNumber = musicPlaylist[currentTrackIndex];

            if (nextAudio && nextAudio.src.includes(`track_${formatTrackNumber(trackNumber)}`)) {
                currentAudio = nextAudio;
                nextAudio = null;
            } else {
                currentAudio = loadTrack(trackNumber);
            }

            setTimeout(() => {
                if (musicEnabled && currentAudio && !isMusicMuted) {
                    currentAudio.volume = 0.7;
                    currentAudio.play().catch(err => console.log('Music play error:', err));

                    nextTrackPreloadTimer = setTimeout(() => {
                        const nextTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
                        const nextTrackNumber = musicPlaylist[nextTrackIndex];
                        nextAudio = loadTrack(nextTrackNumber);
                    }, 60000);
                } else if (isMusicMuted && currentAudio) {
                    currentAudio.volume = 0.7;
                }
            }, 4000);

            currentAudio.onended = () => {
                if (!isMusicMuted) {
                    playNextTrack();
                }
            };
        }

        function startMusic() {
            if (!musicEnabled) return;

            initMusicPlaylist();
            const firstTrack = musicPlaylist[0];
            currentAudio = loadTrack(firstTrack);

            currentAudio.addEventListener('canplaythrough', () => {
                if (musicEnabled && !isMusicMuted) {
                    currentAudio.volume = 0.7;
                    currentAudio.play().catch(err => console.log('Music play error:', err));

                    nextTrackPreloadTimer = setTimeout(() => {
                        const nextTrackIndex = (currentTrackIndex + 1) % musicPlaylist.length;
                        const nextTrackNumber = musicPlaylist[nextTrackIndex];
                        nextAudio = loadTrack(nextTrackNumber);
                    }, 60000);
                }
            }, { once: true });

            currentAudio.onended = () => {
                if (!isMusicMuted) {
                    playNextTrack();
                }
            };
        }

        function pauseMusic() {
            if (currentAudio && !currentAudio.paused) {
                currentAudio.pause();
            }
        }

        function resumeMusic() {
            if (currentAudio && currentAudio.paused && !isMusicMuted) {
                currentAudio.play().catch(err => console.log('Music play error:', err));
            }
        }

        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Only update start screen penguin spawning when hidden
            } else {
                if (gameState === 'start') {
                    lastStartPenguinSpawn = performance.now();
                }
            }
        });

        window.addEventListener('blur', () => {
            pauseMusic();
        });

        window.addEventListener('focus', () => {
            resumeMusic();
        });

        const sprites = {
            igloo: 'igloo.png',
            ship: 'ship.png',
            penguin: 'penguin.png',
            pudgy_jump: 'pudgy_jump.png',
            pudgy_walk_1: 'pudgy_walk_1.png',
            pudgy_walk_2: 'pudgy_walk_2.png',
            pudgy_walk_3: 'pudgy_walk_3.png',
            pudgy_walk_4: 'pudgy_walk_4.png',
            pudgy_walk_5: 'pudgy_walk_5.png',
            pudgy_walk_6: 'pudgy_walk_6.png',
            ground_1: 'ground_1.png',
            ground_2: 'ground_2.png',
            ground_3: 'ground_3.png',
            ground_4: 'ground_4.png',
            ground_5: 'ground_5.png',
            mana_orb: 'mana_orb.png',
            pudgy_nappy: 'pudgy_nappy.png',
            fish_orange: 'fish_orange.png',
            fish_green: 'fish_green.png',
            fish_blowfish: 'fish_blowfish.png',
            ice_slick: 'ice_slick.png',
            metal_box: 'metal_box.png'
        };

        let spritesLoaded = 0;
        const totalSprites = Object.keys(sprites).length;

        // Loop through and load all sprites
        for (const key in sprites) {
            const imageName = sprites[key];
            sprites[key] = new Image();
            sprites[key].src = BASE_URL + imageName;
            sprites[key].onload = onSpriteLoad;
            sprites[key].onerror = () => console.error(`Failed to load ${imageName}`);
        }

        function onSpriteLoad() {
            spritesLoaded++;
            if (spritesLoaded === totalSprites) {
                updateTerrainVisuals();

                if (window.FarcadeSDK) {
                    window.FarcadeSDK.singlePlayer.actions.ready();
                }

                setTimeout(() => {
                    LPatternBackgroundSystem.init();
                }, 100);

                requestAnimationFrame(gameLoop);
            }
        }

        function updateTerrainVisuals() {
            const levelCycle = Math.floor((currentLevel - 1) / 4) % 5;

            if (levelCycle === 0) {
                groundPattern = terrainCtx.createPattern(sprites.ground_1, 'repeat');
                currentOutlineColor = '#00AA00';
                currentSkyColor = '#87CEEB';
            } else if (levelCycle === 1) {
                groundPattern = terrainCtx.createPattern(sprites.ground_2, 'repeat');
                currentOutlineColor = '#9933FF';
                currentSkyColor = '#f9ced9';
            } else if (levelCycle === 2) {
                groundPattern = terrainCtx.createPattern(sprites.ground_3, 'repeat');
                currentOutlineColor = '#5B9BD5';
                currentSkyColor = '#4716b7';
            } else if (levelCycle === 3) {
                groundPattern = terrainCtx.createPattern(sprites.ground_4, 'repeat');
                currentOutlineColor = '#A0826D';
                currentSkyColor = '#c8fc8c';
            } else {
                groundPattern = terrainCtx.createPattern(sprites.ground_5, 'repeat');
                currentOutlineColor = '#5A5A5A';
                currentSkyColor = '#FF3333';
            }
        }

        function startShipSeaRocking() {
            const maxRotation = 4 * Math.PI / 180;
            const swayDuration = 3000;

            function updateRotation() {
                if (gameState !== 'playing') {
                    requestAnimationFrame(updateRotation);
                    return;
                }
                const elapsed = Date.now() - gameStartTime;
                const progress = (elapsed % swayDuration) / swayDuration;
                shipRotation = Math.sin(progress * Math.PI * 2) * maxRotation;
                requestAnimationFrame(updateRotation);
            }
            updateRotation();

            const bobDuration = 4000;
            const bobAmount = 2;

            function updateBob() {
                if (gameState !== 'playing') {
                    requestAnimationFrame(updateBob);
                    return;
                }
                const elapsed = Date.now() - gameStartTime;
                const progress = (elapsed % bobDuration) / bobDuration;
                shipBobOffset = Math.sin(progress * Math.PI * 2) * bobAmount;
                requestAnimationFrame(updateBob);
            }
            updateBob();
        }

        function createPulseAnimation(setter, maxScale, duration) {
            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                let newScale;

                if (progress < 0.5) {
                    const t = progress * 2;
                    newScale = 1 + (maxScale - 1) * (1 - Math.pow(1 - t, 3));
                } else {
                    const t = (progress - 0.5) * 2;
                    newScale = maxScale - (maxScale - 1) * (1 - Math.pow(1 - t, 3));
                }

                // Call the setter function directly to update the correct variable
                setter(newScale);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    setter(1); // Reset to base scale
                }
            }
            animate();
        }

        function pulseManaOrb() {
            createPulseAnimation((scale) => { manaOrbScale = scale; }, 1.2, 400);
        }

        function pulseIgloo() {
            createPulseAnimation((scale) => { iglooScale = scale; }, 1.15, 400);
        }

        function pulseExit() {
            createPulseAnimation((scale) => { exitScale = scale; }, 1.15, 400);
        }

        function flashSpellButton(spell) {
            const button = spellButtons.find(b => b.spell === spell);
            if (button) {
                button.flashState = 1;
                button.flashStartTime = Date.now();
            }
        }

        class Lemming {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 18;
                this.vy = 0;
                this.width = 25;
                this.height = 38;
                this.alive = true;
                this.swimming = false;
                this.bobPhase = Math.random() * Math.PI * 2;
                this.animationFrame = 0;
                this.lastAnimationTime = performance.now();
                this.animationInterval = 125;
                this.trapped = false;
                this.trappedX = 0;
                this.trappedY = 0;
                this.trappedSlideVx = 0;
                this.trappedOnSlick = null;
                this.trappedFlipped = false;
                this.isFlying = false;
                this.flyVx = 0;
                this.flyVy = 0;
                this.spinSpeed = 0;
                this.spinAngle = 0;
            }

            checkCeiling(fromY, toY) {
                const centerX = this.x + this.width / 2;
                const checkY = fromY + this.height * 0.55; // just under wall check
                return isSolidIgnoringBlueRampsCached(centerX, checkY);
            }

            update(deltaTime = 16.67) {
                if (!this.alive) return;

                // Handle flying state
                if (this.isFlying) {
                    this.updateFlying(deltaTime);
                    return;
                }

                // Handle trapped state
                if (this.trapped) {
                    // Apply sliding motion
                    const dt = deltaTime / 1000;
                    this.trappedX += this.trappedSlideVx * dt;

                    // Update flip direction based on slide velocity
                    if (this.trappedSlideVx > 0) {
                        this.trappedFlipped = false; // Sliding right, face right
                    } else if (this.trappedSlideVx < 0) {
                        this.trappedFlipped = true; // Sliding left, face left
                    }

                    // Bounce off ice slick boundaries
                    if (this.trappedOnSlick) {
                        const slickLeft = this.trappedOnSlick.x + 16; // Match collision zone
                        const slickRight = slickLeft + 64;
                        const penguinCenter = this.trappedX + this.width / 2;

                        if (penguinCenter <= slickLeft || penguinCenter >= slickRight) {
                            this.trappedSlideVx = -this.trappedSlideVx;
                            // Clamp position to stay within bounds
                            if (penguinCenter <= slickLeft) {
                                this.trappedX = slickLeft - this.width / 2;
                            } else {
                                this.trappedX = slickRight - this.width / 2;
                            }
                        }
                    }

                    this.x = this.trappedX;
                    this.y = this.trappedY;

                    // Continue animation while trapped
                    const now = performance.now();
                    if (now - this.lastAnimationTime >= this.animationInterval) {
                        this.animationFrame++;
                        this.lastAnimationTime = now;
                    }
                    return;
                }

                const dt = deltaTime / 1000;

                const direction = this.vx > 0 ? 1 : -1;
                const groundCheckX = this.x + this.width / 2;
                const feetY = this.y + this.height;

                if (feetY >= UI_ZONE_Y) {
                    if (!this.swimming) {
                        this.swimming = true;
                        this.y = UI_ZONE_Y - this.height + 10;
                    }
                }

                // Swimming behavior
                if (this.swimming) {
                    this.bobPhase += 0.1 * (deltaTime / 16.67);
                    const bobOffset = Math.sin(this.bobPhase) * 5;
                    this.y = UI_ZONE_Y - this.height + 10 + bobOffset;

                    this.x += this.vx * dt;

                    if (isSolidPixelCached(groundCheckX, feetY - 20)) {
                        this.swimming = false;
                        this.vy = 0;
                        for (let checkY = feetY - 30; checkY <= feetY; checkY++) {
                            if (isSolidPixelCached(groundCheckX, checkY)) {
                                this.y = checkY - this.height;
                                break;
                            }
                        }
                    }

                    // Falling behavior
                } else if (!isSolidPixelCached(groundCheckX, feetY + 1)) {
                    this.vy += 10368 * dt;
                    this.vy = Math.min(this.vy, 1440);

                    const fallDistance = this.vy * dt;
                    const oldY = this.y;
                    let landed = false;

                    const steps = Math.ceil(fallDistance / 2);
                    const stepSize = fallDistance / steps;

                    for (let step = 1; step <= steps; step++) {
                        const checkY = oldY + stepSize * step;
                        const checkFeetY = checkY + this.height;

                        if (isSolidPixelCached(groundCheckX, checkFeetY)) {
                            this.y = checkY;
                            this.vy = 0;
                            landed = true;

                            for (let checkY2 = checkFeetY - 3; checkY2 <= checkFeetY + 3; checkY2++) {
                                if (isSolidPixelCached(groundCheckX, checkY2)) {
                                    this.y = checkY2 - this.height;
                                    break;
                                }
                            }
                            break;
                        }
                    }

                    if (!landed) {
                        this.y += fallDistance;
                    }

                    // Walking behavior
                } else {
                    this.vy = 0;

                    for (let checkY = feetY - 1; checkY <= feetY + 3; checkY++) {
                        if (isSolidPixelCached(groundCheckX, checkY)) {
                            const newY = checkY - this.height;

                            // Only snap if ceiling isn't blocked
                            if (!this.checkCeiling(this.y, newY)) {
                                this.y = newY;
                            } else {
                                // Ceiling is blocking - check if stuck on blue ramp
                                const centerX = this.x + this.width / 2;
                                if (isBlueRampCached(centerX, checkY)) {
                                    // Push penguin down to fall off the blue ramp
                                    this.y += 16;
                                    // Don't do attemptMovement this frame
                                    return;
                                }
                            }
                            break;
                        }
                    }
                    this.attemptMovement(dt);
                }

                // Making sure our penguins stay in canvas
                if (this.x <= 0 || this.x >= canvas.width - this.width) {
                    this.vx = -this.vx;
                    if (this.x <= 0) {
                        this.x = 1;
                    } else {
                        this.x = canvas.width - this.width - 1;
                    }
                }

                // Check mana orb collision
                if (manaOrb && manaOrb.active) {
                    const dx = (this.x + this.width / 2) - manaOrb.x;
                    const dy = (this.y + this.height / 2) - manaOrb.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 40) {
                        collectManaOrb();
                    }
                }

                // Check nappy penguin collision
                if (nappyPenguin && nappyPenguin.active) {
                    const dx = (this.x + this.width / 2) - nappyPenguin.x;
                    const dy = (this.y + this.height / 2) - (nappyPenguin.y + 40);
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < 45) {
                        wakeNappyPenguin();
                    }
                }

                // Check fish collision
                fishes.forEach(fish => {
                    if (fish.checkCollisionWithLemming(this)) {
                        collectFish(fish);
                    }
                });

                // Check blowfish collision
                if (blowfish && blowfish.checkCollisionWithLemming(this)) {
                    collectBlowfish();
                }

                // Check ice slick collision
                if (iceSlick && iceSlick.checkCollision(this)) {
                    iceSlick.trapPenguin(this);
                }

                // Check metal box collision - extract if stuck inside
                if (metalBox) {
                    const lemmingCenterX = this.x + this.width / 2;
                    const lemmingCenterY = this.y + this.height / 2;

                    const insideBox = lemmingCenterX >= metalBox.x &&
                        lemmingCenterX <= metalBox.x + metalBox.width &&
                        lemmingCenterY >= metalBox.y &&
                        lemmingCenterY <= metalBox.y + metalBox.height;

                    if (insideBox) {
                        // Push out in the direction of least resistance
                        const distToLeft = lemmingCenterX - metalBox.x;
                        const distToRight = (metalBox.x + metalBox.width) - lemmingCenterX;
                        const distToTop = lemmingCenterY - metalBox.y;
                        const distToBottom = (metalBox.y + metalBox.height) - lemmingCenterY;

                        const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);

                        if (minDist === distToLeft) {
                            this.x = metalBox.x - this.width - 1;
                        } else if (minDist === distToRight) {
                            this.x = metalBox.x + metalBox.width + 1;
                        } else if (minDist === distToTop) {
                            this.y = metalBox.y - this.height - 1;
                        } else {
                            this.y = metalBox.y + metalBox.height + 1;
                        }

                        this.vx = -this.vx; // Turn around
                    }
                }


                // Reaching the igloo
                if (exit && this.distance(this.x + this.width / 2, this.y + this.height / 2, exit.x, exit.y) < 60) {
                    this.alive = false;
                    lemmingsSaved++;
                    score++;

                    scoreAnimation.active = true;
                    scoreAnimation.startTime = Date.now();

                    pulseExit();
                    return;
                }
            }

            attemptMovement(dt) {
                const direction = this.vx > 0 ? 1 : -1;
                const speed = Math.abs(this.vx);
                const newX = this.x + direction * speed * dt;
                const bodyY = this.y + this.height / 2;
                const feetY = this.y + this.height;

                const wallCheckX = direction > 0 ? newX + this.width : newX;

                if (isSolidIgnoringBlueRampsCached(wallCheckX, bodyY)) {
                    // Can't step up - turn around
                    this.vx = -this.vx;
                    return;
                }

                this.x = newX;
            }

            distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            }

            launchFromIce(angle, speed) {
                this.trapped = false;
                this.trappedOnSlick = null;
                this.trappedSlideVx = 0;
                this.isFlying = true;
                this.isFlying = true;
                this.flyVx = Math.cos(angle) * speed;
                this.flyVy = -Math.sin(angle) * speed;
                this.spinSpeed = 720;
                this.spinAngle = 0;
                this.vy = 0;
            }

            updateFlying(deltaTime) {
                const dt = deltaTime / 1000;

                // Apply gravity
                this.flyVy += 500 * dt;

                // Update spin
                this.spinAngle += this.spinSpeed * dt;

                // Calculate movement
                const dx = this.flyVx * dt;
                const dy = this.flyVy * dt;
                const distance = Math.hypot(dx, dy);

                // Swept collision
                const steps = Math.max(1, Math.ceil(distance / 3));

                for (let step = 1; step <= steps; step++) {
                    const t = step / steps;
                    const newX = this.x + dx * t;
                    const newY = this.y + dy * t;

                    const centerX = newX + this.width / 2;
                    const centerY = newY + this.height / 2;
                    const topY = newY + 3;
                    const bottomY = newY + this.height - 3;

                    let hitSomething = false;
                    let hitCeiling = false;
                    let hitFloor = false;

                    // Top collision
                    if (this.flyVy < 0) {
                        if (isSolidPixelCached(centerX, topY)) {
                            hitCeiling = true;
                            hitSomething = true;
                        }
                    }

                    // Bottom collision
                    if (this.flyVy > 0) {
                        if (isSolidPixelCached(centerX, bottomY)) {
                            hitFloor = true;
                            hitSomething = true;
                        }
                    }

                    if (hitSomething) {
                        if (hitCeiling) {
                            this.isFlying = false;
                            this.flyVx = 0;
                            this.flyVy = 0;
                            this.vy = 0;
                            this.spinAngle = 0;
                            return;
                        } else if (hitFloor) {
                            // Land on ground
                            let groundY = bottomY;
                            for (let checkY = bottomY; checkY <= bottomY + 10; checkY++) {
                                if (isSolidPixelCached(centerX, checkY)) {
                                    groundY = checkY;
                                    break;
                                }
                            }
                            this.y = groundY - this.height;
                            this.isFlying = false;
                            this.flyVx = 0;
                            this.flyVy = 0;
                            this.vy = 0;
                            this.spinAngle = 0;
                            return;
                        }
                        return;
                    }

                    this.x = newX;
                    this.y = newY;
                }

                // Boundary checks
                if (this.x < 0) {
                    this.x = 0;
                    this.flyVx = Math.abs(this.flyVx) * 0.3;
                }
                if (this.x + this.width > canvas.width) {
                    this.x = canvas.width - this.width;
                    this.flyVx = -Math.abs(this.flyVx) * 0.3;
                }
                if (this.y < 0) {
                    this.y = 0;
                    this.flyVy = Math.abs(this.flyVy) * 0.3;
                }
                if (this.y + this.height > canvas.height) {
                    this.alive = false;
                }
            }

            draw() {
                if (!this.alive) return;

                ctx.save();

                const spriteWidth = 40;
                const spriteHeight = 60;
                const offsetX = (spriteWidth - this.width) / 2;
                const offsetY = (spriteHeight - this.height) / 2;

                const now = performance.now();
                if (now - this.lastAnimationTime >= this.animationInterval) {
                    this.animationFrame++;
                    this.lastAnimationTime = now;
                }

                const animationSequence = [0, 1, 2, 3, 4, 5, 4, 3, 2, 1];
                const currentFrame = animationSequence[this.animationFrame % animationSequence.length];

                const walkSprites = [
                    sprites.pudgy_walk_1,
                    sprites.pudgy_walk_2,
                    sprites.pudgy_walk_3,
                    sprites.pudgy_walk_4,
                    sprites.pudgy_walk_5,
                    sprites.pudgy_walk_6
                ];
                const currentSprite = walkSprites[currentFrame];

                // Draw trapped (on back)
                if (this.trapped) {
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate(-Math.PI / 2); // -90 degrees so they face up
                    if (this.trappedFlipped) {
                        ctx.scale(1, -1); // Flip vertically in rotated space = horizontal flip visually
                    }
                    ctx.drawImage(currentSprite, -spriteWidth / 2, -spriteHeight / 2, spriteWidth, spriteHeight);
                }
                // Draw flying (spinning)
                else if (this.isFlying) {
                    ctx.translate(this.x + this.width / 2, this.y + this.height / 2);
                    ctx.rotate((this.spinAngle * Math.PI) / 180);
                    ctx.drawImage(currentSprite, -spriteWidth / 2, -spriteHeight / 2, spriteWidth, spriteHeight);
                }
                // Draw normal
                else {
                    if (this.vx < 0) {
                        ctx.translate(this.x + this.width + offsetX, this.y - offsetY);
                        ctx.scale(-1, 1);
                        ctx.drawImage(currentSprite, 0, 0, spriteWidth, spriteHeight);
                    } else {
                        ctx.drawImage(currentSprite, this.x - offsetX, this.y - offsetY, spriteWidth, spriteHeight);
                    }
                }

                ctx.restore();
            }
        }

        class StartScreenPenguin {
            constructor() {
                this.x = -50;
                this.y = canvas.height / 2 - 19;
                this.vx = 18;
                this.width = 25;
                this.height = 38;
                this.animationFrame = 0;
                this.lastAnimationTime = performance.now();
                this.animationInterval = 125;
                this.lastUpdateTime = performance.now();
            }

            update() {
                const now = performance.now();
                const deltaTime = Math.min(now - this.lastUpdateTime, 100);
                this.lastUpdateTime = now;

                const dt = deltaTime / 1000;
                this.x += this.vx * dt;
            }

            isOffScreen() {
                return this.x > canvas.width + 50;
            }

            draw() {
                ctx.save();

                const spriteWidth = 40;
                const spriteHeight = 60;
                const offsetX = (spriteWidth - this.width) / 2;
                const offsetY = (spriteHeight - this.height) / 2;

                const now = performance.now();
                if (now - this.lastAnimationTime >= this.animationInterval) {
                    this.animationFrame++;
                    this.lastAnimationTime = now;
                }

                const animationSequence = [0, 1, 2, 3, 4, 5, 4, 3, 2, 1];
                const currentFrame = animationSequence[this.animationFrame % animationSequence.length];

                const walkSprites = [
                    sprites.pudgy_walk_1,
                    sprites.pudgy_walk_2,
                    sprites.pudgy_walk_3,
                    sprites.pudgy_walk_4,
                    sprites.pudgy_walk_5,
                    sprites.pudgy_walk_6
                ];
                const currentSprite = walkSprites[currentFrame];

                ctx.drawImage(currentSprite, this.x - offsetX, this.y - offsetY, spriteWidth, spriteHeight);

                ctx.restore();
            }
        }

        class Fish {
            constructor() {
                this.type = Math.random() < 0.5 ? 'orange' : 'green';
                this.sprite = this.type === 'orange' ? sprites.fish_orange : sprites.fish_green;

                this.movingRight = Math.random() < 0.5;

                const speed = canvas.width / 15;
                this.baseVx = this.movingRight ? speed : -speed;
                this.vx = this.baseVx;

                this.x = this.movingRight ? -60 : canvas.width + 60;

                const seaTop = UI_ZONE_Y - 18;
                const seaBottom = canvas.height;
                const seaHeight = seaBottom - seaTop;

                this.topY = seaTop + 8 + Math.random() * 8;
                this.bottomY = seaTop + seaHeight * (0.4 + Math.random() * 0.4);
                this.waveAmplitude = (this.bottomY - this.topY) / 2;
                this.centerY = this.topY + this.waveAmplitude;
                this.y = this.centerY;

                this.wavePhase = Math.random() * Math.PI * 2;
                this.baseWaveSpeed = 0.002;
                this.waveSpeed = this.baseWaveSpeed;

                this.width = 48;
                this.height = 36;

                this.collisionWidth = 64;
                this.collisionHeight = 48;

                this.active = true;
                this.lastUpdateTime = performance.now();
            }

            update(deltaTime, currentGameSpeed) {
                if (!this.active) return;

                updateSineWaveMovement(this, deltaTime, currentGameSpeed);

                // Check if off screen
                if (this.movingRight && this.x > canvas.width + 60) {
                    this.active = false;
                } else if (!this.movingRight && this.x < -60) {
                    this.active = false;
                }
            }

            checkCollisionWithLemming(lemming) {
                if (!this.active) return false;
                return checkEntityLemmingCollision(this.x, this.y, this.collisionWidth, this.collisionHeight, lemming);
            }

            draw() {
                if (!this.active) return;

                ctx.save();

                const drawWidth = this.width;
                const drawHeight = this.height;

                // Always treat this.x, this.y as the center
                if (!this.movingRight) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(-1, 1);
                    ctx.drawImage(this.sprite, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                } else {
                    ctx.drawImage(this.sprite, this.x - drawWidth / 2, this.y - drawHeight / 2, drawWidth, drawHeight);
                }

                ctx.restore();
            }
        }

        class Blowfish {
            constructor() {
                this.sprite = sprites.fish_blowfish;

                this.movingRight = Math.random() < 0.5;

                this.baseSpeed = canvas.width / 25;

                this.x = this.movingRight ? 80 : canvas.width - 80;

                const seaTop = UI_ZONE_Y - 18;
                const seaBottom = canvas.height;
                const seaHeight = seaBottom - seaTop;

                this.topY = seaTop + 8 + Math.random() * 8;
                this.bottomY = seaTop + seaHeight * (0.4 + Math.random() * 0.4);
                this.waveAmplitude = (this.bottomY - this.topY) / 2;
                this.centerY = this.topY + this.waveAmplitude;
                this.y = this.centerY;

                this.wavePhase = Math.random() * Math.PI * 2;
                this.baseWaveSpeed = 0.0015;

                // Calculate vx and waveSpeed based on direction
                this.baseVx = this.movingRight ? this.baseSpeed : -this.baseSpeed;
                this.vx = this.baseVx;
                this.waveSpeed = this.baseWaveSpeed;

                this.width = 60;
                this.height = 45;

                this.collisionWidth = 70;
                this.collisionHeight = 55;

                this.active = true;
                this.collected = false;
                this.lastParticleTime = 0;
            }

            update(deltaTime, currentGameSpeed) {
                if (!this.active) return;

                const dt = deltaTime / 1000;

                // Update speed based on current direction
                this.baseVx = this.movingRight ? this.baseSpeed : -this.baseSpeed;

                updateSineWaveMovement(this, deltaTime, currentGameSpeed);

                // Check bounds and reverse direction
                if (this.x <= 80) {
                    this.x = 80;
                    this.movingRight = true;
                } else if (this.x >= canvas.width - 80) {
                    this.x = canvas.width - 80;
                    this.movingRight = false;
                }
            }

            checkCollisionWithLemming(lemming) {
                if (!this.active || this.collected) return false;
                return checkEntityLemmingCollision(this.x, this.y, this.collisionWidth, this.collisionHeight, lemming);
            }

            draw() {
                if (!this.active) return;

                ctx.save();

                const drawWidth = this.width;
                const drawHeight = this.height;

                // Always treat this.x, this.y as the center
                if (!this.movingRight) {
                    ctx.translate(this.x, this.y);
                    ctx.scale(-1, 1);
                    ctx.drawImage(this.sprite, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
                } else {
                    ctx.drawImage(this.sprite, this.x - drawWidth / 2, this.y - drawHeight / 2, drawWidth, drawHeight);
                }

                ctx.restore();
            }
        }

        class IceSlick {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 96;
                this.height = 48;
                // Remove: this.active = true;
                this.trappedPenguins = [];
                this.blinking = false;
                this.blinkCount = 0;
                this.blinkStartTime = 0;
                this.blinkDuration = 150;
            }

            trapPenguin(lemming) {
                if (!this.trappedPenguins.includes(lemming)) {
                    lemming.trapped = true;
                    lemming.trappedX = lemming.x;
                    lemming.trappedY = lemming.y + 15;
                    // Give penguin a random sliding velocity
                    lemming.trappedSlideVx = (Math.random() - 0.5) * 30; // Random speed between -15 and 15
                    lemming.trappedOnSlick = this; // Store reference to the ice slick
                    this.trappedPenguins.push(lemming);

                    // Create trapping particles
                    const colors = ['#88DDFF', '#AAEEFF', '#CCFFFF', '#FFFFFF'];
                    for (let i = 0; i < 8; i++) {
                        const angle = Math.random() * Math.PI * 2;
                        const speed = 0.5 + Math.random() * 1;
                        const color = colors[Math.floor(Math.random() * colors.length)];

                        particles.push({
                            x: lemming.x + lemming.width / 2,
                            y: lemming.y + lemming.height / 2,
                            vx: Math.cos(angle) * speed,
                            vy: Math.sin(angle) * speed - 0.5,
                            life: 1.0,
                            decay: 0.015 + Math.random() * 0.01,
                            color: color
                        });
                    }
                }
            }

            checkCollision(lemming) {
                if (lemming.trapped || lemming.isFlying || !lemming.alive) return false;

                const lemmingCenterX = lemming.x + lemming.width / 2;
                const lemmingBottomY = lemming.y + lemming.height;

                // Tighter collision zone: 80px wide (centered), 20px tall (top surface only)
                const collisionX = this.x + 8; // Center horizontally (96 - 80 = 16, divided by 2 = 8)
                const collisionY = this.y;
                const collisionWidth = 80;
                const collisionHeight = 20;

                return lemmingCenterX >= collisionX &&
                    lemmingCenterX <= collisionX + collisionWidth &&
                    lemmingBottomY >= collisionY &&
                    lemmingBottomY <= collisionY + collisionHeight;
            }

            startBlinking() {
                this.blinking = true;
                this.blinkCount = 0;
                this.blinkStartTime = Date.now();
            }

            updateBlinking() {
                if (!this.blinking) return;

                const elapsed = Date.now() - this.blinkStartTime;
                const totalCycles = Math.floor(elapsed / this.blinkDuration);

                if (totalCycles >= 4) { // 2 blinks = 4 cycles (on-off-on-off)
                    this.blinking = false;
                    this.launchPenguins();
                }
            }

            launchPenguins() {
                this.trappedPenguins.forEach(lemming => {
                    if (lemming.alive) {
                        const angleInDegrees = 30 + Math.random() * 120; // 30-150 degrees
                        const angleInRadians = (angleInDegrees * Math.PI) / 180;
                        const speed = 300 + Math.random() * 150;

                        lemming.launchFromIce(angleInRadians, speed);

                        // Create launch particles
                        const colors = ['#FF4444', '#FF6666', '#FFAA88', '#FFD700'];
                        for (let i = 0; i < 12; i++) {
                            const angle = Math.random() * Math.PI * 2;
                            const particleSpeed = 2 + Math.random() * 2;
                            const color = colors[Math.floor(Math.random() * colors.length)];

                            particles.push({
                                x: lemming.x + lemming.width / 2,
                                y: lemming.y + lemming.height / 2,
                                vx: Math.cos(angle) * particleSpeed,
                                vy: Math.sin(angle) * particleSpeed - 1.5,
                                life: 1.0,
                                decay: 0.012 + Math.random() * 0.008,
                                color: color
                            });
                        }
                    }
                });

                this.trappedPenguins = [];
            }

            isPointInside(x, y) {
                return x >= this.x &&
                    x <= this.x + this.width &&
                    y >= this.y &&
                    y <= this.y + this.height;
            }

            draw() {
                ctx.save();

                // Apply red tint if blinking
                if (this.blinking) {
                    const elapsed = Date.now() - this.blinkStartTime;
                    const isRed = Math.floor((elapsed / this.blinkDuration) % 2) === 0;

                    if (isRed) {
                        // Create a temporary canvas for the tinted sprite
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = this.width;
                        tempCanvas.height = this.height;
                        const tempCtx = tempCanvas.getContext('2d');

                        // Draw the sprite
                        tempCtx.drawImage(sprites.ice_slick, 0, 0, this.width, this.height);

                        // Apply red tint
                        tempCtx.globalCompositeOperation = 'source-atop';
                        tempCtx.fillStyle = 'rgba(255, 50, 50, 0.7)';
                        tempCtx.fillRect(0, 0, this.width, this.height);

                        // Draw the tinted sprite to main canvas
                        ctx.drawImage(tempCanvas, this.x, this.y);
                    } else {
                        ctx.drawImage(sprites.ice_slick, this.x, this.y, this.width, this.height);
                    }
                } else {
                    ctx.drawImage(sprites.ice_slick, this.x, this.y, this.width, this.height);
                }

                ctx.restore();
            }
        }

        class MetalBox {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 96;
                this.height = 96;
                this.rotation = 0; // Current rotation in degrees (0, 90, 180, 270)
                this.targetRotation = 90; // Next rotation target
                this.lastRotationTime = Date.now();
                this.isRotating = false;
                this.rotationStartTime = 0;
                this.rotationDuration = 400;
                this.rotationInterval = 4000;
            }

            update() {
                const now = Date.now();

                if (!this.isRotating) {
                    // Check if it's time to start rotating
                    if (now - this.lastRotationTime >= this.rotationInterval) {
                        this.isRotating = true;
                        this.rotationStartTime = now;
                        this.targetRotation = (this.rotation + 90) % 360;
                    }
                } else {
                    // Currently rotating
                    const elapsed = now - this.rotationStartTime;

                    if (elapsed >= this.rotationDuration) {
                        // Rotation complete
                        this.rotation = this.targetRotation;
                        this.isRotating = false;
                        this.lastRotationTime = now;
                    }
                }
            }

            getCurrentRotation() {
                if (!this.isRotating) {
                    return this.rotation;
                }

                // Interpolate during rotation
                const elapsed = Date.now() - this.rotationStartTime;
                const progress = Math.min(elapsed / this.rotationDuration, 1);

                // Smooth easing
                const easeProgress = progress < 0.5
                    ? 2 * progress * progress
                    : 1 - Math.pow(-2 * progress + 2, 2) / 2;

                const startRotation = this.rotation;
                const rotationDiff = 90; // Always rotating by 90 degrees

                return startRotation + rotationDiff * easeProgress;
            }

            checkCollision(lemming) {
                if (!lemming.alive || lemming.trapped || lemming.isFlying) return false;

                const lemmingCenterX = lemming.x + lemming.width / 2;
                const lemmingCenterY = lemming.y + lemming.height / 2;

                return lemmingCenterX >= this.x &&
                    lemmingCenterX <= this.x + this.width &&
                    lemmingCenterY >= this.y &&
                    lemmingCenterY <= this.y + this.height;
            }

            draw() {
                ctx.save();

                // Translate to center of box
                ctx.translate(this.x + this.width / 2, this.y + this.height / 2);

                // Apply rotation
                const currentRotation = this.getCurrentRotation();
                ctx.rotate((currentRotation * Math.PI) / 180);

                // Draw centered
                ctx.drawImage(sprites.metal_box, -this.width / 2, -this.height / 2, this.width, this.height);

                ctx.restore();
            }
        }

        function createEmanatingParticle(x, y, colorPalette) {
            const angle = Math.random() * Math.PI * 2;
            const speed = 0.3 + Math.random() * 0.4;
            const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];

            particles.push({
                x: x,
                y: y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                decay: 0.006 + Math.random() * 0.004,
                color: color,
                noGravity: true
            });
        }

        function generatePoints() {
            points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    isTerrain: Math.random() < terrainRatio
                });
            }
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        let terrainShapes = [];

        function generateTerrain() {
            generatePoints();
            terrainShapes = [];

            updateTerrainVisuals();

            const bottomSafeZone = UI_ZONE_Y - 50;

            for (let i = 0; i < points.length; i++) {
                if (!points[i].isTerrain) continue;

                const centerX = points[i].x;
                const centerY = points[i].y;

                if (centerY > bottomSafeZone - 100) continue;

                const platformType = Math.random();
                let blobPoints = [];

                if (platformType < 0.4) {
                    const platformWidth = 200 + Math.random() * 300;
                    const platformHeight = 60 + Math.random() * 80;
                    const angle = (Math.random() - 0.5) * 0.5;

                    const numPointsInBlob = 10 + Math.floor(Math.random() * 6);
                    for (let j = 0; j < numPointsInBlob; j++) {
                        const t = j / numPointsInBlob;
                        const localAngle = t * Math.PI * 2;
                        const localRadius = (Math.abs(Math.cos(localAngle)) * platformWidth / 2 +
                            Math.abs(Math.sin(localAngle)) * platformHeight / 2) *
                            (0.8 + Math.random() * 0.4);

                        const x = centerX + Math.cos(localAngle + angle) * localRadius;
                        const y = centerY + Math.sin(localAngle + angle) * localRadius;

                        if (y < bottomSafeZone) {
                            blobPoints.push({ x, y });
                        }
                    }
                } else {
                    const radius = 80 + Math.random() * 60;
                    const numPointsInBlob = 8 + Math.floor(Math.random() * 6);

                    for (let j = 0; j < numPointsInBlob; j++) {
                        const angle = (j / numPointsInBlob) * Math.PI * 2;
                        const r = radius * (0.7 + Math.random() * 0.6);
                        const x = centerX + Math.cos(angle) * r;
                        const y = centerY + Math.sin(angle) * r;

                        if (y < bottomSafeZone) {
                            blobPoints.push({ x, y });
                        }
                    }
                }

                if (blobPoints.length >= 3) {
                    terrainShapes.push(blobPoints);
                }
            }

            drawTerrainOnly();
            updateCollisionCache();
            findSpawnPoints();
            spawnManaOrb();
            spawnNappyPenguin();
            spawnIceSlick();
            spawnMetalBox();
            drawStaticTerrain();
        }

        // Generic helper: Check if position is too close to entrance/exit
        function isTooCloseToSpawnPoints(x, y, minDistance = 120) {
            const distToEntrance = entrance ? distance(x, y, entrance.x, entrance.y) : Infinity;
            const distToExit = exit ? distance(x, y, exit.x, exit.y) : Infinity;
            return distToEntrance < minDistance || distToExit < minDistance;
        }

        // Generic helper: Find valid surface spawn points
        function findValidSurfacePoints(minDistanceFromSpawns = 120) {
            const surfacePoints = [];
            const scanStep = 30;
            const bottomSafeZone = UI_ZONE_Y - 50;

            for (let x = 80; x < canvas.width - 80; x += scanStep) {
                for (let y = 100; y < bottomSafeZone; y += scanStep) {
                    if (isTerrainAt(x, y)) {
                        const hasSpaceAbove = !isTerrainAt(x, y - 50) && !isTerrainAt(x, y - 35);

                        if (hasSpaceAbove) {
                            const leftOk = isTerrainAt(x - scanStep, y) || isTerrainAt(x - scanStep, y + 12);
                            const rightOk = isTerrainAt(x + scanStep, y) || isTerrainAt(x + scanStep, y + 12);
                            const notInBottomUI = y < UI_ZONE_Y;

                            if (leftOk && rightOk && notInBottomUI && !isTooCloseToSpawnPoints(x, y, minDistanceFromSpawns)) {
                                surfacePoints.push({ x, y });
                            }
                        }
                    }
                }
            }

            return surfacePoints;
        }

        // Generic helper: Find actual surface from a terrain point
        function findActualSurface(x, y) {
            let surfaceY = y;
            while (surfaceY > 0 && isTerrainAt(x, surfaceY - 1)) {
                surfaceY--;
            }
            return surfaceY;
        }

        function spawnNappyPenguin() {
            nappyPenguin = null;
            if (currentLevel < 13) return;

            const validPoints = findValidSurfacePoints(120);

            if (validPoints.length > 0) {
                const spawnPoint = validPoints[Math.floor(Math.random() * validPoints.length)];
                const surfaceY = findActualSurface(spawnPoint.x, spawnPoint.y);

                nappyPenguin = {
                    x: spawnPoint.x,
                    y: surfaceY - 32,
                    active: true,
                    breathPhase: 0,
                    zPhase: 0
                };
            }
        }

        function spawnIceSlick() {
            iceSlick = null;

            if (currentLevel < 9) {
                return;
            }

            const validPoints = findValidSurfacePoints(120);

            if (validPoints.length > 0) {
                const spawnPoint = validPoints[Math.floor(Math.random() * validPoints.length)];
                const surfaceY = findActualSurface(spawnPoint.x, spawnPoint.y);

                iceSlick = new IceSlick(
                    spawnPoint.x - 48, // Center the 96px wide slick
                    surfaceY - 10 // Place slightly above surface
                );

                console.log('Ice slick spawned at:', iceSlick.x, iceSlick.y);
            } else {
                console.log('No valid spawn points found for ice slick');
            }
        }

        function spawnMetalBox() {
            metalBox = null;
            if (currentLevel < 5) return;

            const bottomUIZone = UI_ZONE_Y;
            const attempts = 50;

            for (let i = 0; i < attempts; i++) {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = 100 + Math.random() * (bottomUIZone - 200);

                // Skip if too close to spawn points
                if (isTooCloseToSpawnPoints(x, y, 120)) continue;

                const checkRadius = 48;
                let validPosition = true;

                for (let dx = -checkRadius; dx <= checkRadius; dx += 10) {
                    for (let dy = -checkRadius; dy <= checkRadius; dy += 10) {
                        if (Math.sqrt(dx * dx + dy * dy) <= checkRadius) {
                            if (isSolidPixelCached(x + dx, y + dy)) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    if (!validPosition) break;
                }

                if (validPosition) {
                    metalBox = new MetalBox(x - 48, y - 48);

                    // Draw metal box to collision canvas
                    collisionCtx.fillStyle = '#8B4513'; // Same brown as terrain
                    collisionCtx.fillRect(metalBox.x, metalBox.y, metalBox.width, metalBox.height);

                    // Update collision cache for this region
                    updateCollisionCacheRegion(metalBox.x, metalBox.y, metalBox.width, metalBox.height);

                    break;
                }
            }
        }

        function spawnManaOrb() {
            manaOrb = null;
            if (currentLevel < 9) return;

            const bottomUIZone = UI_ZONE_Y;
            const attempts = 50;

            for (let i = 0; i < attempts; i++) {
                const x = 100 + Math.random() * (canvas.width - 200);
                const y = 100 + Math.random() * (bottomUIZone - 200);

                // Skip if too close to spawn points
                if (isTooCloseToSpawnPoints(x, y, 120)) continue;

                const checkRadius = 30;
                let validPosition = true;

                for (let dx = -checkRadius; dx <= checkRadius; dx += 10) {
                    for (let dy = -checkRadius; dy <= checkRadius; dy += 10) {
                        if (Math.sqrt(dx * dx + dy * dy) <= checkRadius) {
                            if (isSolidPixelCached(x + dx, y + dy)) {
                                validPosition = false;
                                break;
                            }
                        }
                    }
                    if (!validPosition) break;
                }

                if (validPosition) {
                    manaOrb = {
                        x: x,
                        y: y,
                        active: true,
                        bobPhase: 0
                    };
                    break;
                }
            }
        }

        function collectManaOrb() {
            if (!manaOrb || !manaOrb.active) return;

            const numParticles = 20;
            const colors = ['#00BFFF', '#0088FF', '#00DDFF', '#44DDFF', '#88EEFF'];

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                const color = colors[Math.floor(Math.random() * colors.length)];

                particles.push({
                    x: manaOrb.x,
                    y: manaOrb.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01,
                    color: color
                });
            }

            mana += 200;

            manaTextAnimations.push({
                x: 100,
                y: canvas.height - 120,
                text: '+200',
                life: 1.0,
                startTime: Date.now()
            });

            pulseManaOrb();

            manaOrb.active = false;

            manaAnimation.active = true;
            manaAnimation.startTime = Date.now();
        }

        function wakeNappyPenguin() {
            if (!nappyPenguin || !nappyPenguin.active) return;

            const numParticles = 15;
            const colors = ['#FFD700', '#FFA500', '#FF8C00', '#FFFF00', '#FFC700'];

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1.5 + Math.random() * 1.5;
                const color = colors[Math.floor(Math.random() * colors.length)];

                particles.push({
                    x: nappyPenguin.x,
                    y: nappyPenguin.y + 22,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01,
                    color: color
                });
            }

            const newLemming = new Lemming(nappyPenguin.x - 12, nappyPenguin.y);
            lemmings.push(newLemming);
            maxLemmings++;
            lemmingsSpawned++;

            penguinCountTextAnimations.push({
                x: 30,
                y: 80,
                text: '+1',
                life: 1.0,
                startTime: Date.now()
            });

            nappyPenguin.active = false;
        }

        function collectFish(fish) {
            if (!fish || !fish.active) return;

            const numParticles = 12;
            const colors = fish.type === 'orange'
                ? ['#FFA500', '#FF8C00', '#FFB84D', '#FF9933']
                : ['#00FF88', '#00DD77', '#33FFAA', '#00CC66'];

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1.5 + Math.random() * 1.5;
                const color = colors[Math.floor(Math.random() * colors.length)];

                particles.push({
                    x: fish.x,
                    y: fish.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01,
                    color: color
                });
            }

            mana += 40;

            manaTextAnimations.push({
                x: fish.x,
                y: fish.y,
                text: '+40',
                life: 1.0,
                startTime: Date.now()
            });

            fishEatenThisLevel++;

            fish.active = false;

            manaAnimation.active = true;
            manaAnimation.startTime = Date.now();
        }

        function collectBlowfish() {
            if (!blowfish || !blowfish.active || blowfish.collected) return;

            blowfish.collected = true;

            const numParticles = 25;
            const colors = ['#FFD700', '#FFA500', '#FFFF00', '#FFB84D', '#FFC700'];

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 2;
                const color = colors[Math.floor(Math.random() * colors.length)];

                particles.push({
                    x: blowfish.x,
                    y: blowfish.y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.008 + Math.random() * 0.008,
                    color: color
                });
            }

            mana += 200;

            manaTextAnimations.push({
                x: blowfish.x,
                y: blowfish.y,
                text: '+200',
                life: 1.0,
                startTime: Date.now()
            });

            blowfish.active = false;

            manaAnimation.active = true;
            manaAnimation.startTime = Date.now();
        }

        function updateManaOrb(deltaTime) {
            if (!manaOrb || !manaOrb.active) return;

            manaOrb.bobPhase += 0.05 * (deltaTime / 16.67);
        }

        function updateNappyPenguin(deltaTime) {
            if (!nappyPenguin || !nappyPenguin.active) return;

            nappyPenguin.breathPhase += 0.0006 * deltaTime;
            const breathCycle = nappyPenguin.breathPhase % 1.5;

            if (breathCycle < 1.0) {
                nappyPenguinScale = 1 + Math.sin(breathCycle * Math.PI * 2) * 0.04;
            } else {
                nappyPenguinScale = 1;
            }

            nappyPenguin.zPhase += 0.0005 * deltaTime;
        }

        function drawManaOrb() {
            if (!manaOrb || !manaOrb.active) return;

            const bobOffset = Math.sin(manaOrb.bobPhase) * 8;
            const orbSize = 48;

            ctx.save();
            ctx.translate(manaOrb.x, manaOrb.y + bobOffset);
            ctx.scale(manaOrbScale, manaOrbScale);
            ctx.drawImage(sprites.mana_orb, -orbSize / 2, -orbSize / 2, orbSize, orbSize);
            ctx.restore();
        }

        function drawNappyPenguin() {
            if (!nappyPenguin || !nappyPenguin.active) return;

            const penguinWidth = 60;
            const penguinHeight = 45;

            ctx.save();
            ctx.translate(nappyPenguin.x, nappyPenguin.y + penguinHeight / 2);
            ctx.scale(nappyPenguinScale, nappyPenguinScale);
            ctx.drawImage(sprites.pudgy_nappy, -penguinWidth / 2, -penguinHeight / 2, penguinWidth, penguinHeight);
            ctx.restore();

            const zCycle = (nappyPenguin.zPhase % 2);
            const stateIndex = Math.floor(zCycle / 0.5);

            if (stateIndex < 3) {
                ctx.save();
                ctx.fillStyle = '#FFFFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                ctx.font = '28px Luckiest Guy, Arial';
                ctx.textAlign = 'center';

                let zText = '';
                if (stateIndex === 0) zText = 'z';
                else if (stateIndex === 1) zText = 'zZ';
                else if (stateIndex === 2) zText = 'zZz';

                const zX = nappyPenguin.x;
                const zY = nappyPenguin.y - 10;
                const zBob = Math.sin(nappyPenguin.zPhase * Math.PI) * 3;

                const stateProgress = (zCycle % 0.5) / 0.5;
                let alpha;
                if (stateProgress < 0.2) {
                    alpha = stateProgress / 0.2;
                } else if (stateProgress > 0.8) {
                    alpha = (1 - stateProgress) / 0.2;
                } else {
                    alpha = 1;
                }

                ctx.globalAlpha = alpha * 0.9;
                ctx.strokeText(zText, zX, zY + zBob);
                ctx.fillText(zText, zX, zY + zBob);
                ctx.restore();
            }
        }

        function updateTextAnimations(animationArray, yIncrement) {
            const now = Date.now();
            const duration = 1500;

            animationArray.forEach(anim => {
                const elapsed = now - anim.startTime;
                const progress = elapsed / duration;

                anim.life = 1 - progress;
                anim.y += yIncrement;
            });

            // Return a new array containing only the active animations
            return animationArray.filter(anim => anim.life > 0);
        }

        function drawTextAnimations(animationArray, font, textAlign, textBaseline, color) {
            animationArray.forEach(anim => {
                ctx.save();
                ctx.globalAlpha = anim.life;
                ctx.font = font;
                ctx.textAlign = textAlign;
                ctx.textBaseline = textBaseline;
                drawStrokedText(anim.text, anim.x, anim.y, color);
                ctx.restore();
            });
        }

        function drawTerrainOnly() {
            collisionCtx.clearRect(0, 0, collisionCanvas.width, collisionCanvas.height);
            terrainCtx.fillStyle = currentSkyColor;
            terrainCtx.fillRect(0, 0, terrainCanvas.width, terrainCanvas.height);

            terrainShapes.forEach(blobPoints => {
                collisionCtx.save();
                collisionCtx.fillStyle = '#8B4513';
                collisionCtx.beginPath();
                collisionCtx.moveTo(blobPoints[0].x, blobPoints[0].y);

                for (let j = 1; j < blobPoints.length; j++) {
                    const current = blobPoints[j];
                    const next = blobPoints[(j + 1) % blobPoints.length];
                    const cpX = current.x + (next.x - current.x) * 0.5;
                    const cpY = current.y + (next.y - current.y) * 0.5;
                    collisionCtx.quadraticCurveTo(current.x, current.y, cpX, cpY);
                }

                collisionCtx.quadraticCurveTo(
                    blobPoints[blobPoints.length - 1].x,
                    blobPoints[blobPoints.length - 1].y,
                    blobPoints[0].x,
                    blobPoints[0].y
                );
                collisionCtx.fill();
                collisionCtx.restore();

                terrainCtx.save();
                terrainCtx.fillStyle = groundPattern || '#8B4513';
                terrainCtx.strokeStyle = currentOutlineColor;
                terrainCtx.lineWidth = 4;
                terrainCtx.beginPath();
                terrainCtx.moveTo(blobPoints[0].x, blobPoints[0].y);

                for (let j = 1; j < blobPoints.length; j++) {
                    const current = blobPoints[j];
                    const next = blobPoints[(j + 1) % blobPoints.length];
                    const cpX = current.x + (next.x - current.x) * 0.5;
                    const cpY = current.y + (next.y - current.y) * 0.5;
                    terrainCtx.quadraticCurveTo(current.x, current.y, cpX, cpY);
                }

                terrainCtx.quadraticCurveTo(
                    blobPoints[blobPoints.length - 1].x,
                    blobPoints[blobPoints.length - 1].y,
                    blobPoints[0].x,
                    blobPoints[0].y
                );
                terrainCtx.fill();
                terrainCtx.stroke();
                terrainCtx.restore();
            });
        }

        function drawStaticTerrain() {
            ctx.fillStyle = currentSkyColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(terrainCanvas, 0, 0);
            drawSpawnPoints();
        }

        function isTerrainAt(x, y) {
            if (x < 0 || x >= collisionCanvas.width || y < 0 || y >= collisionCanvas.height) return false;
            return isSolidPixel(x, y);
        }

        function findSpawnPoints() {
            const surfacePoints = [];
            const scanStep = 30;
            const bottomSafeZone = UI_ZONE_Y - 50;
            const bottomUIZone = { minY: UI_ZONE_Y };

            const isEasyLevel = currentLevel <= 4;
            const topHalfLimit = canvas.height * 0.5;

            for (let x = 80; x < canvas.width - 80; x += scanStep) {
                for (let y = 100; y < bottomSafeZone; y += scanStep) {
                    if (isTerrainAt(x, y)) {
                        const hasSpaceAbove = !isTerrainAt(x, y - 50) && !isTerrainAt(x, y - 35);

                        if (hasSpaceAbove) {
                            const leftOk = isTerrainAt(x - scanStep, y) || isTerrainAt(x - scanStep, y + 12);
                            const rightOk = isTerrainAt(x + scanStep, y) || isTerrainAt(x + scanStep, y + 12);
                            const notInBottomUI = y < bottomUIZone.minY;

                            if (leftOk && rightOk && notInBottomUI) {
                                surfacePoints.push({ x, y });
                            }
                        }
                    }
                }
            }

            if (surfacePoints.length >= 2) {
                if (isEasyLevel) {
                    const topPoints = surfacePoints.filter(p => p.y < topHalfLimit);
                    const bottomPoints = surfacePoints.filter(p => p.y >= topHalfLimit);

                    if (topPoints.length > 0 && bottomPoints.length > 0) {
                        const entranceSurface = topPoints[Math.floor(Math.random() * topPoints.length)];
                        entrance = { x: entranceSurface.x, y: entranceSurface.y - 60 };

                        const exitSurface = bottomPoints[Math.floor(Math.random() * bottomPoints.length)];
                        exit = { x: exitSurface.x, y: exitSurface.y - 60 };
                    } else {
                        const entranceSurface = surfacePoints[Math.floor(Math.random() * surfacePoints.length)];
                        entrance = { x: entranceSurface.x, y: entranceSurface.y - 60 };

                        let validExits = surfacePoints.filter(p =>
                            distance(p.x, p.y, entrance.x, entrance.y) > 300
                        );

                        if (validExits.length === 0) {
                            validExits = surfacePoints.filter(p =>
                                distance(p.x, p.y, entrance.x, entrance.y) > 200
                            );
                        }

                        if (validExits.length > 0) {
                            const exitSurface = validExits[Math.floor(Math.random() * validExits.length)];
                            exit = { x: exitSurface.x, y: exitSurface.y - 60 };
                        } else {
                            exit = { x: surfacePoints[surfacePoints.length - 1].x, y: surfacePoints[surfacePoints.length - 1].y - 60 };
                        }
                    }
                } else {
                    surfacePoints.sort((a, b) => a.y - b.y);

                    const entranceSurface = surfacePoints[Math.floor(Math.random() * surfacePoints.length)];
                    entrance = { x: entranceSurface.x, y: entranceSurface.y - 60 };

                    let validExits = surfacePoints.filter(p =>
                        distance(p.x, p.y, entrance.x, entrance.y) > 300
                    );

                    if (validExits.length === 0) {
                        validExits = surfacePoints.filter(p =>
                            distance(p.x, p.y, entrance.x, entrance.y) > 200
                        );
                    }

                    if (validExits.length > 0) {
                        const exitSurface = validExits[Math.floor(Math.random() * validExits.length)];
                        exit = { x: exitSurface.x, y: exitSurface.y - 60 };
                    } else {
                        exit = { x: surfacePoints[surfacePoints.length - 1].x, y: surfacePoints[surfacePoints.length - 1].y - 60 };
                    }
                }
            } else {
                const entranceY = 200 + Math.random() * 200;
                const exitY = Math.min(bottomSafeZone - 150, UI_ZONE_Y - 200) + Math.random() * 100;

                entrance = { x: 160, y: entranceY - 50 };
                exit = { x: canvas.width - 160, y: exitY - 50 };
            }
        }

        function drawSpawnPoints() {
            if (entrance) {
                const iglooWidth = 128;
                const iglooHeight = 128;

                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.translate(entrance.x, entrance.y);
                ctx.scale(iglooScale, iglooScale);
                ctx.drawImage(sprites.igloo, -iglooWidth / 2, -iglooHeight / 2, iglooWidth, iglooHeight);
                ctx.restore();
            }

            if (exit) {
                const shipWidth = 128;
                const shipHeight = 128;

                ctx.save();
                ctx.globalAlpha = 0.8;
                ctx.translate(exit.x, exit.y);
                ctx.scale(exitScale, exitScale);
                ctx.rotate(shipRotation);
                ctx.translate(0, shipBobOffset);
                ctx.drawImage(sprites.ship, -shipWidth / 2, -shipHeight / 2, shipWidth, shipHeight);
                ctx.restore();
            }
        }

        function drawSpeedButton() {
            const button = speedButton;

            ctx.save();

            ctx.globalAlpha = 0.8;

            ctx.fillStyle = button.pressed ? '#4CAF50' : '#333';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.fillRect(button.x, button.y, button.width, button.height);
            ctx.strokeRect(button.x, button.y, button.width, button.height);

            ctx.fillStyle = '#fff';
            ctx.font = '32px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (button.pressed) {
                const animSpeed = 20;
                const cycle = Math.floor(button.animationFrame / animSpeed) % 3;

                const arrowY = button.y + button.height / 2 + 5;
                const spacing = 25;
                const totalWidth = spacing * 2;
                const startX = button.x + button.width / 2 - totalWidth / 2;

                for (let i = 0; i < 3; i++) {
                    ctx.fillStyle = i <= cycle ? '#FFD700' : '#666';
                    ctx.fillText('>', startX + i * spacing, arrowY);
                }

                button.animationFrame++;
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillText('>', button.x + button.width / 2, button.y + button.height / 2 + 5);
                button.animationFrame = 0;
            }

            ctx.restore();
        }

        function drawSpellButtons() {
            const now = Date.now();

            spellButtons.forEach(button => {
                ctx.save();

                // Check if button is flashing
                let isFlashing = false;

                if (button.flashState > 0) {
                    const elapsed = now - button.flashStartTime;
                    const flashDuration = 400;
                    const totalDuration = flashDuration * 2;

                    if (elapsed < totalDuration) {
                        const cycle = Math.floor((elapsed / flashDuration) % 2);
                        isFlashing = cycle === 0;
                    } else {
                        button.flashState = 0;
                    }
                }

                // Set opacity based on selection and flash state
                if (isFlashing) {
                    ctx.globalAlpha = 0.3;
                } else {
                    ctx.globalAlpha = currentSpell === button.spell ? 0.8 : 0.5;
                }

                // Draw button circle with grey color if flashing
                ctx.fillStyle = isFlashing ? '#808080' : button.color;
                ctx.beginPath();
                ctx.arc(button.x, button.y, button.radius, 0, 2 * Math.PI);
                ctx.fill();

                ctx.strokeStyle = currentSpell === button.spell ? '#FFD700' : '#fff';
                ctx.lineWidth = currentSpell === button.spell ? 4 : 2;
                ctx.stroke();

                // Draw mana cost on button center when using spell
                if (button.showingCost) {
                    const elapsed = now - button.costStartTime;
                    const costDuration = 800; // Show for 800ms

                    if (elapsed < costDuration) {
                        // Calculate shake (only for first 150ms)
                        let shakeX = 0;
                        let shakeY = 0;
                        const shakeDuration = 100;
                        if (elapsed < shakeDuration) {
                            const shakeIntensity = 2 * (1 - elapsed / shakeDuration); // Decay over time
                            const frequency = 20; // High frequency for rapid shake
                            shakeX = Math.sin(elapsed / frequency) * shakeIntensity;
                            shakeY = Math.cos(elapsed / frequency * 1.3) * shakeIntensity;
                        }

                        // Calculate fade-out alpha
                        const fadeStartTime = 500; // Start fading at 500ms
                        let alpha = 1;
                        if (elapsed > fadeStartTime) {
                            const fadeProgress = (elapsed - fadeStartTime) / (costDuration - fadeStartTime);
                            alpha = 1 - fadeProgress;
                        }

                        ctx.globalAlpha = alpha;
                        ctx.font = '36px Luckiest Guy, Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';

                        // Draw the number centered, then add the minus to the left
                        const numberText = button.lastCost.toString();
                        const numberWidth = ctx.measureText(numberText).width;
                        const minusWidth = ctx.measureText('-').width;

                        // Center the number itself, with a small vertical offset and shake
                        const verticalOffset = 5;
                        const numberX = button.x + shakeX;
                        const textY = button.y + verticalOffset + shakeY;
                        const minusX = numberX - numberWidth / 2 - minusWidth / 2;

                        drawStrokedText('-', minusX, textY, '#FFFFFF', '#000000', 3);
                        drawStrokedText(numberText, numberX, textY, '#FFFFFF', '#000000', 3);
                    } else {
                        button.showingCost = false;
                    }
                }

                ctx.restore();
            });
        }

        function isPointInButton(x, y, button) {
            return x >= button.x && x <= button.x + button.width &&
                y >= button.y && y <= button.y + button.height;
        }

        function isPointInCircleButton(x, y, button) {
            const dx = x - button.x;
            const dy = y - button.y;
            return Math.sqrt(dx * dx + dy * dy) <= button.radius;
        }

        function getSnappedLine(start, end) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            const dist = Math.sqrt(dx * dx + dy * dy);

            if (dist < 10) return null;

            const angle = Math.atan2(dy, dx);

            const angles = [
                0,
                Math.PI / 4,
                -Math.PI / 4,
                Math.PI,
                3 * Math.PI / 4,
                -3 * Math.PI / 4
            ];

            let snappedAngle = angles[0];
            let minDiff = Math.abs(angle - angles[0]);

            for (let i = 1; i < angles.length; i++) {
                let diff = Math.abs(angle - angles[i]);
                if (diff > Math.PI) {
                    diff = 2 * Math.PI - diff;
                }
                if (diff < minDiff) {
                    minDiff = diff;
                    snappedAngle = angles[i];
                }
            }

            const endX = start.x + Math.cos(snappedAngle) * dist;
            const endY = start.y + Math.sin(snappedAngle) * dist;

            return [start, { x: endX, y: endY }];
        }

        function getLinePixelLength(line) {
            if (!line || line.length < 2) return 0;

            let totalLength = 0;
            for (let i = 1; i < line.length; i++) {
                const dx = line[i].x - line[i - 1].x;
                const dy = line[i].y - line[i - 1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            return Math.round(totalLength * 0.5);
        }

        function createSpellParticles(x, y, spell) {
            const numParticles = 10 + Math.floor(Math.random() * 6);

            let colors;
            if (spell === 'blue') {
                colors = ['#0066FF', '#0088FF', '#00AAFF', '#0044DD', '#3399FF'];
            } else if (spell === 'red') {
                colors = ['#FF4444', '#FF6666', '#FF2222', '#CC3333', '#FF5555'];
            } else if (spell === 'purple') {
                colors = ['#AA44FF', '#BB66FF', '#9933FF', '#8822DD', '#CC77FF'];
            }

            for (let i = 0; i < numParticles; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 1 + Math.random() * 1.5;
                const color = colors[Math.floor(Math.random() * colors.length)];

                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed - 1,
                    life: 1.0,
                    decay: 0.01 + Math.random() * 0.01,
                    color: color
                });
            }
        }

        function createIntermissionParticles() {
            intermissionParticles = [];
            const colors = ['#0066FF', '#FF4444', '#AA44FF', '#FFD700', '#00FF88'];
            const particlesPerBurst = 15;
            const numBursts = 12;
            const spacing = canvas.width / (numBursts + 1);
            const startTime = performance.now();

            for (let burst = 0; burst < numBursts; burst++) {
                const x = spacing * (burst + 1);
                const y = 200;
                const delay = burst * 100;

                for (let i = 0; i < particlesPerBurst; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 2 + Math.random() * 3;
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    intermissionParticles.push({
                        x: x,
                        y: y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed - 2,
                        life: 1.0,
                        decay: 0.008 + Math.random() * 0.008,
                        color: color,
                        startTime: startTime + delay,
                        started: false
                    });
                }
            }
        }

        function createJumpingPudgies() {
            jumpingPudgies = [];
            const pudgyWidth = 540;
            const pudgyHeight = 716;
            const startTime = performance.now();

            const positions = [
                { x: canvas.width * 0.2, delay: 0 },
                { x: canvas.width * 0.5, delay: 800 },
                { x: canvas.width * 0.8, delay: 400 }
            ];

            positions.forEach(pos => {
                jumpingPudgies.push({
                    x: pos.x,
                    y: canvas.height + pudgyHeight / 2,
                    width: pudgyWidth,
                    height: pudgyHeight,
                    startY: canvas.height + pudgyHeight / 2,
                    targetY: canvas.height / 2,
                    jumpDuration: 2000,
                    startTime: startTime + pos.delay,
                    active: false
                });
            });
        }

        function updateJumpingPudgies() {
            const now = performance.now();

            jumpingPudgies.forEach(pudgy => {
                if (!pudgy.active && now >= pudgy.startTime) {
                    pudgy.active = true;
                }

                if (pudgy.active) {
                    const elapsed = now - pudgy.startTime;
                    const progress = (elapsed % pudgy.jumpDuration) / pudgy.jumpDuration;

                    const heightDiff = pudgy.startY - pudgy.targetY;
                    pudgy.y = pudgy.startY - heightDiff * (1 - Math.pow(2 * progress - 1, 2));
                }
            });
        }

        function drawJumpingPudgies() {
            jumpingPudgies.forEach(pudgy => {
                if (pudgy.active) {
                    ctx.save();
                    ctx.drawImage(
                        sprites.pudgy_jump,
                        pudgy.x - pudgy.width / 2,
                        pudgy.y - pudgy.height / 2,
                        pudgy.width,
                        pudgy.height
                    );
                    ctx.restore();
                }
            });
        }

        function updateParticles() {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                // Only apply gravity if particle doesn't have noGravity flag
                if (!p.noGravity) {
                    p.vy += 0.1;
                }
                p.life -= p.decay;
            });
            particles = particles.filter(p => p.life > 0);
        }

        function updateSea(deltaTime) {
            seaWaveOffset += 0.002 * deltaTime;

            if (Math.random() < 0.3) {
                const seaY = UI_ZONE_Y - 18;
                const x = Math.random() * canvas.width;

                const wave1 = Math.sin(x * 0.02 + seaWaveOffset) * 2;
                const wave2 = Math.sin(x * 0.03 - seaWaveOffset * 1.5) * 1.5;
                const waveY = seaY + wave1 + wave2;

                foamParticles.push({
                    x: x,
                    y: waveY - 1,
                    vx: 0.3 + Math.random() * 0.4,
                    vy: (Math.random() - 0.5) * 0.2,
                    life: 1.0,
                    decay: 0.015 + Math.random() * 0.01,
                    size: 1 + Math.random() * 2
                });
            }

            foamParticles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= p.decay;
            });
            foamParticles = foamParticles.filter(p => p.life > 0 && p.x < canvas.width + 10);
        }

        function drawSea() {
            const seaHeight = 18;
            const seaY = UI_ZONE_Y - seaHeight;

            ctx.save();

            ctx.fillStyle = 'rgba(30, 100, 180, 0.85)';
            ctx.beginPath();

            ctx.moveTo(canvas.width, canvas.height);

            for (let x = canvas.width; x >= 0; x -= 2) {
                const wave1 = Math.sin(x * 0.025 + seaWaveOffset * 1.5) * 3;
                const wave2 = Math.sin(x * 0.018 - seaWaveOffset * 1.2) * 2;
                const y = UI_ZONE_Y + 8 + wave1 + wave2;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(0, seaY);

            for (let x = 0; x <= canvas.width; x += 2) {
                const wave1 = Math.sin(x * 0.02 + seaWaveOffset) * 2;
                const wave2 = Math.sin(x * 0.03 - seaWaveOffset * 1.5) * 1.5;
                const wave3 = Math.sin(x * 0.015 + seaWaveOffset * 0.8) * 1;
                const y = seaY + wave1 + wave2 + wave3;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = 'rgba(60, 140, 220, 0.4)';
            ctx.beginPath();

            ctx.moveTo(canvas.width, canvas.height);

            for (let x = canvas.width; x >= 0; x -= 2) {
                const wave1 = Math.sin(x * 0.025 + seaWaveOffset * 1.5) * 3;
                const wave2 = Math.sin(x * 0.018 - seaWaveOffset * 1.2) * 2;
                const y = UI_ZONE_Y + 8 + wave1 + wave2;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(0, seaY + 4);

            for (let x = 0; x <= canvas.width; x += 2) {
                const wave1 = Math.sin(x * 0.025 - seaWaveOffset * 2) * 1.5;
                const wave2 = Math.sin(x * 0.018 + seaWaveOffset * 1.2) * 1;
                const y = seaY + 4 + wave1 + wave2;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();

            foamParticles.forEach(p => {
                ctx.globalAlpha = p.life * 0.9;
                ctx.fillStyle = '#FFFFFF';
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });

            ctx.restore();
        }

        function updateIntermissionParticles() {
            const now = performance.now();
            intermissionParticles.forEach(p => {
                if (!p.started && now >= p.startTime) {
                    p.started = true;
                }
                if (p.started) {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15;
                    p.life -= p.decay;
                }
            });
            intermissionParticles = intermissionParticles.filter(p => p.life > 0);
        }

        function drawParticles() {
            particles.forEach(p => {
                ctx.save();
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            });
        }

        function drawIntermissionParticles() {
            intermissionParticles.forEach(p => {
                if (p.started) {
                    ctx.save();
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            });
        }

        function handlePointerDown(pos) {
            if (gameState === 'start') {
                if (helpPopup.visible) {
                    if (isPointInButton(pos.x, pos.y, helpPopup.okButton)) {
                        helpPopup.visible = false;
                        return;
                    }

                    const popupWidth = canvas.width * 0.8;
                    const popupHeight = canvas.height * 0.8;
                    const popupX = (canvas.width - popupWidth) / 2;
                    const popupY = (canvas.height - popupHeight) / 2;

                    if (pos.x < popupX || pos.x > popupX + popupWidth ||
                        pos.y < popupY || pos.y > popupY + popupHeight) {
                        helpPopup.visible = false;
                        return;
                    }

                    return;
                }

                if (startButton.visible && isPointInButton(pos.x, pos.y, startButton)) {
                    startGame();
                    startShipSeaRocking();
                    return;
                }

                if (helpButton.visible && isPointInButton(pos.x, pos.y, helpButton)) {
                    helpPopup.visible = true;
                    return;
                }

                return;
            }

            if (gameState === 'intermission' && intermissionButton.visible) {
                if (isPointInButton(pos.x, pos.y, intermissionButton)) {
                    startNextLevel();
                    return;
                }
            }

            if (gameState === 'gameover' && gameOverButton.visible) {
                if (isPointInButton(pos.x, pos.y, gameOverButton)) {
                    restartGame();
                    return;
                }
            }

            if (gameState !== 'playing') return;

            if (isPointInButton(pos.x, pos.y, speedButton)) {
                speedButton.pressed = !speedButton.pressed;
                gameSpeed = speedButton.pressed ? 8 : 1;
                return;
            }

            for (let button of spellButtons) {
                if (isPointInCircleButton(pos.x, pos.y, button)) {
                    currentSpell = button.spell;
                    return;
                }
            }

            const minMana = currentSpell === 'red' ? 40 : currentSpell === 'purple' ? 40 : 1;

            if (mana < minMana) {
                createSpellParticles(pos.x, pos.y, currentSpell);
                flashSpellButton(currentSpell);
                return;
            }

            if (currentSpell === 'red') {
                createExplosion(pos.x, pos.y);
                return;
            }

            if (currentSpell === 'purple') {
                placePurpleWall(pos.x, pos.y);
                return;
            }

            isDrawing = true;
            drawStart = pos;
            drawCurrent = pos;
        }

        function handlePointerMove(pos) {
            if (!isDrawing) return;
            drawCurrent = pos;
        }

        function handleDrawingEnd() {
            if (!isDrawing) return;
            isDrawing = false;

            if (drawStart && drawCurrent && currentSpell === 'blue') {
                const snappedLine = getSnappedLine(drawStart, drawCurrent);

                createSpellParticles(drawStart.x, drawStart.y, 'blue');

                if (snappedLine) {
                    const lineCost = getLinePixelLength(snappedLine);

                    if (mana < lineCost) {
                        flashSpellButton('blue');
                        drawStart = null;
                        drawCurrent = null;
                        return;
                    }

                    showSpellCost('blue', lineCost);

                    const color = 'rgba(0, 102, 255, 255)';
                    drawnLines.push({ line: snappedLine, color: color });
                    drawLine(snappedLine, color);

                    mana -= lineCost;

                    manaAnimation.active = true;
                    manaAnimation.startTime = Date.now();
                }
            }

            drawStart = null;
            drawCurrent = null;
        }

        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        function getTouchPos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const touch = event.touches[0] || event.changedTouches[0];

            return {
                x: (touch.clientX - rect.left) * scaleX,
                y: (touch.clientY - rect.top) * scaleY
            };
        }

        // Replace the drawLine function
        function drawLine(line, color) {
            if (!line || line.length < 2) return;

            // Calculate line length
            const dx = line[1].x - line[0].x;
            const dy = line[1].y - line[0].y;
            const lineLength = Math.sqrt(dx * dx + dy * dy);

            const lineObj = {
                line: line,
                color: color,
                createdAt: Date.now(),
                particles: []
            };

            // FIXED: Initialize particles based on line length
            // Target density: 1 particle per 16 pixels (like 16 particles on a 256px line)
            const totalParticles = Math.max(2, Math.round(lineLength / 16));
            for (let i = 0; i < totalParticles; i++) {
                lineObj.particles.push({
                    offset: i / totalParticles,
                    wavePhase: (i % 2 === 0) ? 0 : Math.PI
                });
            }

            drawnLines.push(lineObj);

            // Draw to collision canvas
            collisionCtx.strokeStyle = color;
            collisionCtx.lineWidth = 12;
            collisionCtx.lineCap = 'round';
            collisionCtx.lineJoin = 'round';
            collisionCtx.beginPath();
            collisionCtx.moveTo(line[0].x, line[0].y);
            for (let i = 1; i < line.length; i++) {
                collisionCtx.lineTo(line[i].x, line[i].y);
            }
            collisionCtx.stroke();

            // Update collision cache
            const minX = Math.min(line[0].x, line[line.length - 1].x) - 10;
            const minY = Math.min(line[0].y, line[line.length - 1].y) - 10;
            const maxX = Math.max(line[0].x, line[line.length - 1].x) + 10;
            const maxY = Math.max(line[0].y, line[line.length - 1].y) + 10;
            updateCollisionCacheRegion(minX, minY, maxX - minX, maxY - minY);
        }

        function drawAnimatedBlueRamps(currentTime) {
            drawnLines.forEach(lineObj => {
                if (lineObj.color !== 'rgba(0, 102, 255, 255)') return;

                const line = lineObj.line;
                if (!line || line.length < 2) return;

                const startX = line[0].x;
                const startY = line[0].y;
                const endX = line[1].x;
                const endY = line[1].y;

                const dx = endX - startX;
                const dy = endY - startY;
                const length = Math.sqrt(dx * dx + dy * dy);
                const perpX = -dy / length;
                const perpY = dx / length;

                const time = Date.now() / 1000;

                // Simple pulsing aura - pulse range from 0.4 to 0.8
                // DOES NOT WORK
                const pulseAmount = Math.sin(time) * 0.2 + 0.6;

                for (let i = 3; i >= 1; i--) {
                    const layerAlpha = pulseAmount * (i / 3);
                    ctx.strokeStyle = `rgba(100, 150, 255, ${layerAlpha})`;
                    ctx.lineWidth = 12 + i * 2;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.lineTo(endX, endY);
                    ctx.stroke();
                }

                // Main line
                ctx.strokeStyle = '#0066FF';
                ctx.lineWidth = 12;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();

                if (!lineObj.particles) {
                    lineObj.particles = [];
                    const totalParticles = Math.max(2, Math.round(length / 16));
                    for (let i = 0; i < totalParticles; i++) {
                        lineObj.particles.push({
                            offset: i / totalParticles,
                            wavePhase: (i % 2 === 0) ? 0 : Math.PI
                        });
                    }
                }

                const pixelSpeed = 64;

                lineObj.particles.forEach(particle => {
                    // Particle moves at constant pixel speed
                    const pixelsPerSecond = pixelSpeed;
                    const secondsToCompleteLoop = length / pixelsPerSecond;
                    const progress = ((time / secondsToCompleteLoop) + particle.offset) % 1;

                    const baseX = startX + (endX - startX) * progress;
                    const baseY = startY + (endY - startY) * progress;

                    // Wave based on pixel position only (no scrolling)
                    const pixelPosition = progress * length;
                    const wavesPerPixel = 1 / 85; // One wave every 85 pixels
                    const waveOffset = Math.sin(pixelPosition * wavesPerPixel * 2 * Math.PI + particle.wavePhase) * 4;

                    const x = baseX + perpX * waveOffset;
                    const y = baseY + perpY * waveOffset;

                    const size = 1.5 + Math.sin(time * 2 + particle.offset * 16) * 0.75;

                    const gradient = ctx.createRadialGradient(x, y, 0, x, y, size * 2);
                    gradient.addColorStop(0, 'rgba(200, 230, 255, 0.9)');
                    gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');

                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(x, y, size * 2, 0, Math.PI * 2);
                    ctx.fill();
                });
            });
        }

        function handleDrawingEnd() {
            if (!isDrawing) return;
            isDrawing = false;

            if (drawStart && drawCurrent && currentSpell === 'blue') {
                const snappedLine = getSnappedLine(drawStart, drawCurrent);

                createSpellParticles(drawStart.x, drawStart.y, 'blue');

                if (snappedLine) {
                    const lineCost = getLinePixelLength(snappedLine);

                    if (mana < lineCost) {
                        flashSpellButton('blue');
                        drawStart = null;
                        drawCurrent = null;
                        return;
                    }

                    showSpellCost('blue', lineCost);

                    const color = 'rgba(0, 102, 255, 255)';
                    drawnLines.push({ line: snappedLine, color: color });
                    drawLine(snappedLine, color);

                    mana -= lineCost;

                    manaAnimation.active = true;
                    manaAnimation.startTime = Date.now();
                }
            }

            drawStart = null;
            drawCurrent = null;
        }

        function placePurpleWall(x, y) {
            const wallCost = 40;

            createSpellParticles(x, y, 'purple');

            if (mana < wallCost) {
                flashSpellButton('purple');
                return;
            }

            showSpellCost('purple', wallCost);

            const wallHeight = 64;
            const halfHeight = wallHeight / 2;
            const wallLine = [
                { x: x, y: y + halfHeight },
                { x: x, y: y - halfHeight }
            ];

            const color = 'rgba(170, 68, 255, 255)';
            drawnLines.push({ line: wallLine, color: color });
            drawLine(wallLine, color);

            mana -= wallCost;

            manaAnimation.active = true;
            manaAnimation.startTime = Date.now();
        }

        function createExplosion(x, y) {
            const explosionCost = 40;

            createSpellParticles(x, y, 'red');

            if (mana < explosionCost) {
                flashSpellButton('red');
                return;
            }

            // Check if clicking on ice slick
            if (iceSlick && iceSlick.isPointInside(x, y)) {
                iceSlick.startBlinking();
            }

            showSpellCost('red', explosionCost);

            const radius = 40;
            const numPoints = 12 + Math.floor(Math.random() * 8);
            const explosionPoints = [];

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const radiusVariation = 0.6 + Math.random() * 0.2;
                const finalRadius = radius * radiusVariation;
                const angleNoise = (Math.random() - 0.5) * 0.3;
                const finalAngle = angle + angleNoise;

                explosionPoints.push({
                    x: x + Math.cos(finalAngle) * finalRadius,
                    y: y + Math.sin(finalAngle) * finalRadius
                });
            }

            applyExplosionHole(x, y, explosionPoints);

            mana -= explosionCost;

            manaAnimation.active = true;
            manaAnimation.startTime = Date.now();
        }

        function applyExplosionHole(x, y, explosionPoints) {
            if (explosionPoints.length < 3) return;

            collisionCtx.save();
            collisionCtx.globalCompositeOperation = 'destination-out';
            collisionCtx.fillStyle = 'rgba(0, 0, 0, 1)';
            collisionCtx.beginPath();
            collisionCtx.moveTo(explosionPoints[0].x, explosionPoints[0].y);

            for (let i = 1; i < explosionPoints.length; i++) {
                const current = explosionPoints[i];
                const next = explosionPoints[(i + 1) % explosionPoints.length];
                const cpX = current.x + (next.x - current.x) * 0.5;
                const cpY = current.y + (next.y - current.y) * 0.5;
                collisionCtx.quadraticCurveTo(current.x, current.y, cpX, cpY);
            }

            collisionCtx.quadraticCurveTo(
                explosionPoints[explosionPoints.length - 1].x,
                explosionPoints[explosionPoints.length - 1].y,
                explosionPoints[0].x,
                explosionPoints[0].y
            );
            collisionCtx.fill();
            collisionCtx.restore();

            terrainCtx.save();
            terrainCtx.globalCompositeOperation = 'destination-out';
            terrainCtx.fillStyle = 'rgba(0, 0, 0, 1)';
            terrainCtx.beginPath();
            terrainCtx.moveTo(explosionPoints[0].x, explosionPoints[0].y);

            for (let i = 1; i < explosionPoints.length; i++) {
                const current = explosionPoints[i];
                const next = explosionPoints[(i + 1) % explosionPoints.length];
                const cpX = current.x + (next.x - current.x) * 0.5;
                const cpY = current.y + (next.y - current.y) * 0.5;
                terrainCtx.quadraticCurveTo(current.x, current.y, cpX, cpY);
            }

            terrainCtx.quadraticCurveTo(
                explosionPoints[explosionPoints.length - 1].x,
                explosionPoints[explosionPoints.length - 1].y,
                explosionPoints[0].x,
                explosionPoints[0].y
            );
            terrainCtx.fill();
            terrainCtx.restore();

            updateCollisionCacheRegion(x - 50, y - 50, 100, 100);

            // Redraw metal box if it exists (since explosion may have affected it)
            if (metalBox) {
                collisionCtx.fillStyle = '#8B4513';
                collisionCtx.fillRect(metalBox.x, metalBox.y, metalBox.width, metalBox.height);
                updateCollisionCacheRegion(metalBox.x, metalBox.y, metalBox.width, metalBox.height);
            }
        }

        function drawStartScreen() {
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            startScreenPenguins.forEach(penguin => penguin.draw());

            ctx.font = '80px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            drawStrokedText('PINGEUS', canvas.width / 2, 150, '#FFD700', '#000000', 4);

            startButton.x = canvas.width / 2 - startButton.width / 2;
            startButton.y = canvas.height - 300;

            ctx.fillStyle = '#4CAF50';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.fillRect(startButton.x, startButton.y, startButton.width, startButton.height);
            ctx.strokeRect(startButton.x, startButton.y, startButton.width, startButton.height);

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '48px Luckiest Guy, Arial';
            ctx.fillText('PLAY', canvas.width / 2, startButton.y + startButton.height / 2 + 15);

            helpButton.x = canvas.width / 2 - helpButton.width / 2;
            helpButton.y = canvas.height - 180;

            ctx.fillStyle = '#FF4444';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.fillRect(helpButton.x, helpButton.y, helpButton.width, helpButton.height);
            ctx.strokeRect(helpButton.x, helpButton.y, helpButton.width, helpButton.height);

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '36px Luckiest Guy, Arial';
            ctx.fillText('HELP', canvas.width / 2, helpButton.y + helpButton.height / 2 + 12);

            if (helpPopup.visible) {
                drawHelpPopup();
            }
        }

        function drawHelpPopup() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const popupWidth = canvas.width * 0.8;
            const popupHeight = canvas.height * 0.8;
            const popupX = (canvas.width - popupWidth) / 2;
            const popupY = (canvas.height - popupHeight) / 2;
            ctx.fillStyle = '#2c3e50';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 4;
            ctx.fillRect(popupX, popupY, popupWidth, popupHeight);
            ctx.strokeRect(popupX, popupY, popupWidth, popupHeight);

            ctx.textAlign = 'center';

            ctx.font = '38px Luckiest Guy, Arial';
            let yPos = popupY + 90;
            drawStrokedText('LEAD PENGUS FROM IGLOO TO SHIP', canvas.width / 2, yPos, '#FFD700');
            yPos += 120;
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '34px Luckiest Guy, Arial';
            ctx.fillText('Your spells:', canvas.width / 2, yPos);
            yPos += 120;

            ctx.font = '30px Luckiest Guy, Arial';
            const iconSize = 72;
            const iconX = canvas.width / 2 - 240;
            const textOffset = 80;

            ctx.fillStyle = '#0066FF';
            ctx.beginPath();
            ctx.arc(iconX, yPos, iconSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'left';
            ctx.fillText('Draw bridges and ramps', iconX + textOffset, yPos + 10);
            yPos += 120;

            ctx.fillStyle = '#FF4444';
            ctx.beginPath();
            ctx.arc(iconX, yPos, iconSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('Blow up the terrain', iconX + textOffset, yPos + 10);
            yPos += 120;

            ctx.fillStyle = '#AA44FF';
            ctx.beginPath();
            ctx.arc(iconX, yPos, iconSize / 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#FFFFFF';
            ctx.fillText('Make a wall', iconX + textOffset, yPos + 10);
            yPos += 120;

            const buttonWidth = 90;
            const buttonHeight = 60;
            ctx.fillStyle = '#4CAF50';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 2;
            ctx.fillRect(iconX - buttonWidth / 2, yPos - buttonHeight / 2, buttonWidth, buttonHeight);
            ctx.strokeRect(iconX - buttonWidth / 2, yPos - buttonHeight / 2, buttonWidth, buttonHeight);

            ctx.fillStyle = '#FFD700';
            ctx.font = '32px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            const arrowSpacing = 25;
            const totalWidth = arrowSpacing * 2;
            const startX = iconX - totalWidth / 2;

            for (let i = 0; i < 3; i++) {
                ctx.fillText('>', startX + i * arrowSpacing, yPos + 5);
            }

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '30px Luckiest Guy, Arial';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'alphabetic';
            ctx.fillText('Speed up game', iconX + textOffset, yPos + 10);

            helpPopup.okButton.x = canvas.width / 2 - helpPopup.okButton.width / 2;
            helpPopup.okButton.y = popupY + popupHeight - 90;
            ctx.fillStyle = '#FF4444';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.fillRect(helpPopup.okButton.x, helpPopup.okButton.y, helpPopup.okButton.width, helpPopup.okButton.height);
            ctx.strokeRect(helpPopup.okButton.x, helpPopup.okButton.y, helpPopup.okButton.width, helpPopup.okButton.height);
            ctx.fillStyle = '#FFFFFF';
            ctx.font = '36px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            ctx.fillText('OK', canvas.width / 2, helpPopup.okButton.y + helpPopup.okButton.height / 2 + 12);
        }

        function updateStartScreen() {
            startScreenPenguins.forEach(penguin => penguin.update());
            startScreenPenguins = startScreenPenguins.filter(penguin => !penguin.isOffScreen());
        }

        function startGame() {
            gameState = 'playing';
            startScreenPenguins = [];
            generateTerrain();
            gameStartTime = Date.now();
            accumulatedTime = 0;
            lastFrameTime = 0;
            gameActive = true;
            startMusic();
        }

        function restartGame() {
            lemmings = [];
            drawnLines = [];
            lemmingsSpawned = 0;
            lemmingsSaved = 0;
            maxLemmings = 40;
            mana = 2000;
            lastLevelBonus = 2000;
            score = 0;
            accumulatedTime = 0;
            lastFrameTime = 0;
            lastSpawnTime = 0;
            currentLevel = STARTING_LEVEL;
            speedButton.pressed = false;
            gameSpeed = 1;
            currentSpell = 'blue';
            particles = [];
            foamParticles = [];
            manaOrb = null;
            manaTextAnimations = [];
            nappyPenguin = null;
            penguinCountTextAnimations = [];
            gameOverButton.visible = false;
            fishes = [];
            lastFishSpawn = 0;
            fishEatenThisLevel = 0;
            blowfish = null;
            blowfishHasSpawned = false;
            blowfishSpawnTime = Math.random() * 60000;
            iceSlick = null;
            metalBox = null;


            generateTerrain();
            gameStartTime = Date.now();
            gameState = 'playing';
            gameActive = true;
            startShipSeaRocking();

            requestAnimationFrame(gameLoop);
        }

        canvas.addEventListener('mousedown', function (event) {
            const pos = getMousePos(event);
            handlePointerDown(pos);
        });

        canvas.addEventListener('mousemove', function (event) {
            const pos = getMousePos(event);
            handlePointerMove(pos);
        });

        canvas.addEventListener('mouseup', function (event) {
            handleDrawingEnd();
        });

        canvas.addEventListener('touchstart', function (event) {
            event.preventDefault();
            const pos = getTouchPos(event);
            handlePointerDown(pos);
        }, { passive: false });

        canvas.addEventListener('touchmove', function (event) {
            event.preventDefault();
            const pos = getTouchPos(event);
            handlePointerMove(pos);
        }, { passive: false });

        canvas.addEventListener('touchend', function (event) {
            event.preventDefault();
            handleDrawingEnd();
        }, { passive: false });

        if (window.FarcadeSDK) {
            window.FarcadeSDK.on('play_again', () => {
                if (gameState === 'gameover') {
                    restartGame();
                }
            });

            window.FarcadeSDK.on('toggle_mute', (data) => {
                isMusicMuted = data.isMuted;

                if (data.isMuted) {
                    if (currentAudio && !currentAudio.paused) {
                        currentAudio.pause();
                    }
                } else {
                    if (currentAudio && currentAudio.paused && !document.hidden) {
                        currentAudio.volume = 0.7;
                        currentAudio.play().catch(err => console.log('Music play error:', err));
                    }
                }
            });
        }

        function spawnLemming() {
            if (entrance && lemmingsSpawned < maxLemmings) {
                const lemming = new Lemming(entrance.x, entrance.y);
                lemmings.push(lemming);
                lemmingsSpawned++;

                pulseIgloo();
            }
        }

        function drawIntermissionScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            drawJumpingPudgies();

            drawIntermissionParticles();

            ctx.font = '60px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            drawStrokedText(`LEVEL ${currentLevel} COMPLETED`, canvas.width / 2, 150, '#FFD700', '#000000', 4);

            const pulseScale = 1 + Math.sin(Date.now() / 300) * 0.05;
            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2 - 100);
            ctx.scale(pulseScale, pulseScale);
            ctx.font = '48px Luckiest Guy, Arial';
            drawStrokedText(`+${levelCompleteBonus} mana`, 0, 0, '#00BFFF');
            ctx.restore();

            ctx.font = '24px Luckiest Guy, Arial';
            const lineHeight = 36;
            let y = canvas.height / 2 + 50;

            const sentences = currentHint.split('. ').filter(s => s.length > 0);

            sentences.forEach((sentence, index) => {
                const displayText = (index < sentences.length - 1 && !sentence.endsWith('.')) ? sentence + '.' : sentence;
                drawStrokedText(displayText, canvas.width / 2, y, '#FFFFFF');
                y += lineHeight;
            });

            intermissionButton.x = canvas.width / 2 - intermissionButton.width / 2;
            intermissionButton.y = canvas.height - 200;

            ctx.fillStyle = '#4CAF50';
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 3;
            ctx.fillRect(intermissionButton.x, intermissionButton.y, intermissionButton.width, intermissionButton.height);
            ctx.strokeRect(intermissionButton.x, intermissionButton.y, intermissionButton.width, intermissionButton.height);

            ctx.fillStyle = '#FFFFFF';
            ctx.font = '36px Luckiest Guy, Arial';
            ctx.fillText(`ENTER LEVEL ${currentLevel + 1}`, canvas.width / 2, intermissionButton.y + intermissionButton.height / 2 + 12);
        }

        function drawGameOverScreen() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.font = '60px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            drawStrokedText('TIME UP!', canvas.width / 2, canvas.height / 2 - 100, '#FF4444', '#000000', 4);

            ctx.font = '36px Luckiest Guy, Arial';
            drawStrokedText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 - 20, '#FFFFFF');

            ctx.font = '28px Luckiest Guy, Arial';
            drawStrokedText(`Reached Level ${currentLevel}`, canvas.width / 2, canvas.height / 2 + 40, '#FFFFFF');

            if (!window.FarcadeSDK) {
                gameOverButton.x = canvas.width / 2 - gameOverButton.width / 2;
                gameOverButton.y = canvas.height / 2 + 100;

                ctx.fillStyle = '#4CAF50';
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.fillRect(gameOverButton.x, gameOverButton.y, gameOverButton.width, gameOverButton.height);
                ctx.strokeRect(gameOverButton.x, gameOverButton.y, gameOverButton.width, gameOverButton.height);

                ctx.fillStyle = '#FFFFFF';
                ctx.font = '48px Luckiest Guy, Arial';
                ctx.fillText('PLAY', canvas.width / 2, gameOverButton.y + gameOverButton.height / 2 + 15);
            }
        }

        function drawUI() {
            ctx.save();

            const now = Date.now();

            if (scoreAnimation.active) {
                const elapsed = now - scoreAnimation.startTime;
                const duration = 300;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    scoreAnimation.scale = 1 + Math.sin(progress * Math.PI) * 0.2;
                } else {
                    scoreAnimation.active = false;
                    scoreAnimation.scale = 1;
                }
            }

            if (manaAnimation.active) {
                const elapsed = now - manaAnimation.startTime;
                const duration = 200;
                if (elapsed < duration) {
                    const progress = elapsed / duration;
                    manaAnimation.shake = Math.sin(progress * Math.PI * 6) * 5 * (1 - progress);
                } else {
                    manaAnimation.active = false;
                    manaAnimation.shake = 0;
                }
            }

            ctx.save();
            ctx.translate(canvas.width / 2, 60);
            ctx.scale(scoreAnimation.scale, scoreAnimation.scale);
            ctx.font = '64px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            drawStrokedText(`${score}`, 0, 0, '#FFD700');
            ctx.restore();

            ctx.font = '48px Luckiest Guy, Arial';
            ctx.textAlign = 'right';

            const remainingTime = Math.max(0, levelTime - accumulatedTime);
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            drawStrokedText(timeText, canvas.width - 30, 50, '#FFFFFF');

            ctx.textAlign = 'left';
            ctx.font = '40px Luckiest Guy, Arial';
            const penguinText = `${lemmingsSaved}/${lemmingsSpawned}`;
            drawStrokedText(penguinText, 30, 50, '#FFFFFF');

            ctx.save();
            ctx.translate(100 + manaAnimation.shake, canvas.height - 60);
            ctx.font = '64px Luckiest Guy, Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            drawStrokedText(`${mana}`, 0, 0, '#00BFFF');
            ctx.restore();

            ctx.restore();
        }

        function drawGame() {
            if (gameState === 'intermission') {
                drawStaticTerrain();
                drawIntermissionScreen();
                return;
            }

            if (gameState === 'gameover') {
                drawStaticTerrain();
                drawGameOverScreen();
                return;
            }

            drawStaticTerrain();

            drawAnimatedBlueRamps(performance.now());

            drawSea();

            fishes.forEach(fish => fish.draw());

            if (blowfish && blowfish.active) {
                blowfish.draw();
            }

            drawManaOrb();
            drawNappyPenguin();

            if (iceSlick) {
                iceSlick.draw();
            }

            if (metalBox) {
                metalBox.draw();
            }

            if (isDrawing && drawStart && drawCurrent && currentSpell === 'blue') {
                const snappedLine = getSnappedLine(drawStart, drawCurrent);

                if (snappedLine) {
                    ctx.save();
                    ctx.strokeStyle = '#00FF00';
                    ctx.lineWidth = 12;
                    ctx.lineCap = 'round';
                    ctx.globalAlpha = 0.7;

                    ctx.beginPath();
                    ctx.moveTo(snappedLine[0].x, snappedLine[0].y);
                    ctx.lineTo(snappedLine[1].x, snappedLine[1].y);
                    ctx.stroke();
                    ctx.restore();

                    // Draw dynamic cost above the line
                    const lineCost = getLinePixelLength(snappedLine);
                    const costY = drawStart.y - 64;

                    ctx.save();
                    ctx.font = '36px Luckiest Guy, Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    // Draw cost with color based on affordability
                    const canAfford = mana >= lineCost;
                    const costColor = canAfford ? '#00FF00' : '#FF4444';

                    drawStrokedText(`-${lineCost}`, drawStart.x, costY, costColor, '#000000', 3);
                    ctx.restore();
                }
            }

            lemmings.forEach(lemming => lemming.draw());

            ctx.save();
            ctx.fillStyle = 'rgba(30, 100, 180, 0.85)';
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            ctx.lineTo(0, UI_ZONE_Y);

            for (let x = 0; x <= canvas.width; x += 2) {
                const wave1 = Math.sin(x * 0.025 + seaWaveOffset * 1.5) * 3;
                const wave2 = Math.sin(x * 0.018 - seaWaveOffset * 1.2) * 2;
                const y = UI_ZONE_Y + wave1 + wave2;
                ctx.lineTo(x, y);
            }

            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            drawParticles();

            drawUI();
            drawTextAnimations(manaTextAnimations, '48px Luckiest Guy, Arial', 'center', 'middle', '#00BFFF');
            drawTextAnimations(penguinCountTextAnimations, '36px Luckiest Guy, Arial', 'left', 'alphabetic', '#FFD700');
            drawSpeedButton();
            drawSpellButtons();
        }

        function showIntermission() {
            gameState = 'intermission';
            gameActive = false;

            levelCompleteBonus = Math.ceil(lastLevelBonus * 0.8);
            mana += levelCompleteBonus;
            lastLevelBonus = levelCompleteBonus;

            currentHint = gameHints[Math.floor(Math.random() * gameHints.length)];

            createIntermissionParticles();
            createJumpingPudgies();
            intermissionButton.visible = true;

            requestAnimationFrame(gameLoop);
        }

        function startNextLevel() {
            currentLevel++;
            const penguinsForNextLevel = lemmingsSaved;

            lemmings = [];
            drawnLines = [];
            lemmingsSpawned = 0;
            lemmingsSaved = 0;
            maxLemmings = penguinsForNextLevel;
            accumulatedTime = 0;
            lastFrameTime = 0;

            speedButton.pressed = false;
            gameSpeed = 1;
            currentSpell = 'blue';

            intermissionButton.visible = false;
            intermissionParticles = [];

            fishes = [];
            lastFishSpawn = 0;
            fishEatenThisLevel = 0;
            blowfish = null;
            blowfishHasSpawned = false;
            blowfishSpawnTime = Math.random() * 60000;
            iceSlick = null;
            metalBox = null;


            generateTerrain();

            gameStartTime = Date.now();
            gameState = 'playing';
            gameActive = true;
            startShipSeaRocking();
        }

        function nextLevel() {
            showIntermission();
        }

        let lastFrameTime = 0;

        function gameLoop(currentTime) {
            if (gameState === 'start') {
                if (!document.hidden) {
                    if (currentTime - lastStartPenguinSpawn > START_PENGUIN_INTERVAL) {
                        startScreenPenguins.push(new StartScreenPenguin());
                        lastStartPenguinSpawn = currentTime;
                    }

                    updateStartScreen();
                    drawStartScreen();
                }
                requestAnimationFrame(gameLoop);
                return;
            }

            if (gameState === 'intermission') {
                updateIntermissionParticles();
                updateJumpingPudgies();
                drawGame();
                requestAnimationFrame(gameLoop);
                return;
            }

            if (gameState === 'gameover') {
                drawGame();
                return;
            }

            if (!gameActive) return;

            const deltaTime = lastFrameTime ? currentTime - lastFrameTime : 16.67;
            const cappedDeltaTime = Math.min(deltaTime, 100);
            lastFrameTime = currentTime;

            accumulatedTime += cappedDeltaTime * gameSpeed;

            const remainingTime = levelTime - accumulatedTime;

            if (remainingTime <= 0) {
                gameActive = false;

                if (lemmingsSaved > 0) {
                    setTimeout(() => {
                        nextLevel();
                    }, 1000);
                } else {
                    gameState = 'gameover';
                    gameOverButton.visible = !window.FarcadeSDK;

                    setTimeout(() => {
                        drawGame();
                    }, 1000);

                    if (window.FarcadeSDK) {
                        setTimeout(() => {
                            window.FarcadeSDK.singlePlayer.actions.gameOver({ score: score });
                        }, 2000);
                    }
                }
                return;
            }

            const allPenguinsSpawned = lemmingsSpawned >= maxLemmings;
            const noPenguinsActive = lemmings.filter(l => l.alive).length === 0;

            if (allPenguinsSpawned && noPenguinsActive && lemmingsSaved > 0) {
                gameActive = false;
                setTimeout(() => {
                    nextLevel();
                }, 1000);
                return;
            }

            const adjustedSpawnInterval = SPAWN_INTERVAL / gameSpeed;
            if (currentTime - lastSpawnTime > adjustedSpawnInterval) {
                spawnLemming();
                lastSpawnTime = currentTime;
            }

            if (fishEatenThisLevel < MAX_FISH_PER_LEVEL) {
                const adjustedFishSpawnInterval = FISH_SPAWN_INTERVAL / gameSpeed;
                if (currentTime - lastFishSpawn > adjustedFishSpawnInterval) {
                    fishes.push(new Fish());
                    lastFishSpawn = currentTime;
                }
            }

            if (currentLevel >= 5 && !blowfishHasSpawned && accumulatedTime >= blowfishSpawnTime) {
                blowfish = new Blowfish();
                blowfishHasSpawned = true;
            }

            // Generate energy particles radiating from blowfish
            if (blowfish && blowfish.active && !blowfish.collected) {
                if (currentTime - blowfish.lastParticleTime > 250 / gameSpeed) {
                    blowfish.lastParticleTime = currentTime;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 0.2 + Math.random() * 0.125;
                    const colors = ['#FFD700', '#FFA500', '#FFFF00'];
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    particles.push({
                        x: blowfish.x,
                        y: blowfish.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 0.5,
                        decay: 0.002,
                        color: color,
                        noGravity: true
                    });
                }
            }

            const updatesPerFrame = gameSpeed;
            for (let i = 0; i < updatesPerFrame; i++) {
                lemmings.forEach(lemming => lemming.update(cappedDeltaTime));
                updateParticles();
                updateSea(cappedDeltaTime);
                updateManaOrb(cappedDeltaTime);
                updateNappyPenguin(cappedDeltaTime);
                if (iceSlick) {
                    iceSlick.updateBlinking();
                }
                if (metalBox) {
                    metalBox.update();
                }
                manaTextAnimations = updateTextAnimations(manaTextAnimations, -0.5);
                penguinCountTextAnimations = updateTextAnimations(penguinCountTextAnimations, 0.5);
            }

            fishes.forEach(fish => fish.update(cappedDeltaTime, gameSpeed));
            fishes = fishes.filter(fish => fish.active);

            if (blowfish && blowfish.active) {
                blowfish.update(cappedDeltaTime, gameSpeed);
            }

            lemmings = lemmings.filter(lemming => lemming.alive);

            drawGame();

            if (gameActive) {
                requestAnimationFrame(gameLoop);
            }
        }

        const TARGET_RATIO = 2 / 3;
        const EPSILON = 0.0001;

        const LPatternBackgroundSystem = {
            patternCanvas: null,
            borderCanvas: null,
            isInitialized: false,

            config: {
                size: 6,
                thickness: 4,
                spacing: 4,
                color: '#FFD700',
                opacity: 0.5,
                borderWidth: 8
            },

            init: function () {
                if (this.isInitialized) return;

                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => this.init());
                    return;
                }

                this.createCanvases();

                if (this.patternCanvas) {
                    this.drawPattern();
                }

                setTimeout(() => {
                    this.updateBorders();
                }, 100);

                window.addEventListener('resize', () => this.handleResize());

                this.isInitialized = true;
            },

            createCanvases: function () {
                if (window.innerWidth <= 0 || window.innerHeight <= 0) {
                    setTimeout(() => this.createCanvases(), 100);
                    return;
                }

                try {
                    this.patternCanvas = document.createElement('canvas');
                    this.patternCanvas.style.position = 'absolute';
                    this.patternCanvas.style.top = '0';
                    this.patternCanvas.style.left = '0';
                    this.patternCanvas.style.width = '100%';
                    this.patternCanvas.style.height = '100%';
                    this.patternCanvas.style.pointerEvents = 'none';
                    this.patternCanvas.style.zIndex = '1';
                    this.patternCanvas.width = window.innerWidth;
                    this.patternCanvas.height = window.innerHeight;
                    document.body.insertBefore(this.patternCanvas, document.body.firstChild);

                    this.borderCanvas = document.createElement('canvas');
                    this.borderCanvas.style.position = 'absolute';
                    this.borderCanvas.style.top = '0';
                    this.borderCanvas.style.left = '0';
                    this.borderCanvas.style.width = '100%';
                    this.borderCanvas.style.height = '100%';
                    this.borderCanvas.style.pointerEvents = 'none';
                    this.borderCanvas.style.zIndex = '2';
                    this.borderCanvas.width = window.innerWidth;
                    this.borderCanvas.height = window.innerHeight;
                    document.body.insertBefore(this.borderCanvas, document.body.firstChild);
                } catch (error) {
                    console.error("Failed to create canvas elements:", error);
                }
            },

            findGameCanvas: function () {
                return document.getElementById('terrainCanvas');
            },

            getLetterboxingSides: function () {
                const gameCanvas = this.findGameCanvas();
                if (!gameCanvas) {
                    return { top: false, bottom: false, left: false, right: false };
                }

                const canvasRect = gameCanvas.getBoundingClientRect();
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;

                return {
                    left: canvasRect.left > 5,
                    right: (viewportWidth - canvasRect.right) > 5,
                    top: canvasRect.top > 5,
                    bottom: (viewportHeight - canvasRect.bottom) > 5
                };
            },

            updateBorders: function () {
                const screenWidth = window.innerWidth;
                const screenHeight = window.innerHeight;
                const screenRatio = screenWidth / screenHeight;

                let gameWidth;
                let gameHeight;
                let xOffset;
                let yOffset;

                if (screenRatio >= TARGET_RATIO - EPSILON) {
                    gameHeight = screenHeight;
                    gameWidth = gameHeight * TARGET_RATIO;
                    xOffset = (screenWidth - gameWidth) / 2;
                    yOffset = 0;
                } else {
                    gameWidth = screenWidth;
                    gameHeight = gameWidth / TARGET_RATIO;
                    xOffset = 0;
                    yOffset = (screenHeight - gameHeight) / 2;
                }

                const finalTop = Math.ceil(yOffset) - 1;
                const finalHeight = Math.ceil(gameHeight) + 2;

                let finalLeft;
                let finalWidth;

                if (Math.abs(xOffset) < EPSILON) {
                    finalLeft = 0;
                    finalWidth = window.innerWidth + 1;
                } else {
                    finalLeft = Math.round(xOffset) - 1;
                    finalWidth = Math.ceil(gameWidth) + 2;
                }

                const rect = {
                    left: finalLeft,
                    top: finalTop,
                    width: finalWidth,
                    height: finalHeight,
                    right: Math.ceil(xOffset + gameWidth),
                    bottom: Math.ceil(yOffset + gameHeight),
                };

                const gameCanvas = document.getElementById('terrainCanvas');
                if (gameCanvas) {
                    gameCanvas.style.width = rect.width + 'px';
                    gameCanvas.style.height = rect.height + 'px';
                    gameCanvas.style.left = rect.left + 'px';
                    gameCanvas.style.top = rect.top + 'px';
                }

                this.clearBorder();

                if (screenRatio > TARGET_RATIO + EPSILON) {
                    this.drawGameBorder({ left: true, right: true, top: false, bottom: false });
                } else if (screenRatio < TARGET_RATIO - EPSILON) {
                    this.drawGameBorder({ top: true, bottom: true, left: false, right: false });
                }
            },

            drawPattern: function () {
                if (!this.patternCanvas) return;

                const ctx = this.patternCanvas.getContext('2d');
                if (!ctx) return;

                ctx.clearRect(0, 0, this.patternCanvas.width, this.patternCanvas.height);

                const vHeight = this.config.size * 3;
                const hWidth = this.config.size * 2;
                const thickness = this.config.thickness;
                const overlap = hWidth * 0.6;
                const pairWidth = hWidth * 1.6;
                const patternWidth = pairWidth + this.config.spacing;
                const vSpacing = vHeight + this.config.spacing;

                const cols = Math.ceil(this.patternCanvas.width / patternWidth) + 2;
                const rows = Math.ceil(this.patternCanvas.height / vSpacing) + 1;

                for (let row = 0; row < rows; row++) {
                    const rowOffset = (row % 2 === 1) ? patternWidth / 3 : 0;
                    const y = row * vSpacing;
                    const alpha = (row % 2 === 0) ? this.config.opacity * 0.6 : this.config.opacity;

                    for (let col = 0; col < cols; col++) {
                        const x = col * patternWidth - rowOffset;

                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = this.config.color;
                        ctx.fillRect(x, y, thickness, vHeight);
                        ctx.fillRect(x, y + vHeight - thickness, hWidth, thickness);

                        const ix = x + overlap;
                        ctx.fillRect(ix, y, hWidth, thickness);
                        ctx.fillRect(ix + hWidth - thickness, y, thickness, vHeight);
                    }
                }

                ctx.globalAlpha = 1.0;
            },

            drawGameBorder: function (sides) {
                const gameCanvas = this.findGameCanvas();
                if (!gameCanvas || !this.borderCanvas) return;

                const ctx = this.borderCanvas.getContext('2d');
                if (!ctx) return;

                ctx.clearRect(0, 0, this.borderCanvas.width, this.borderCanvas.height);

                const rect = gameCanvas.getBoundingClientRect();
                const bw = this.config.borderWidth;

                ctx.fillStyle = this.config.color;

                if (sides.top) {
                    ctx.fillRect(rect.left - bw, rect.top - bw, rect.width + bw * 2, bw);
                }
                if (sides.bottom) {
                    ctx.fillRect(rect.left - bw, rect.bottom, rect.width + bw * 2, bw);
                }
                if (sides.left) {
                    ctx.fillRect(rect.left - bw, rect.top, bw, rect.height);
                }
                if (sides.right) {
                    ctx.fillRect(rect.right, rect.top, bw, rect.height);
                }
            },

            clearBorder: function () {
                if (!this.borderCanvas) return;
                const ctx = this.borderCanvas.getContext('2d');
                if (ctx) {
                    ctx.clearRect(0, 0, this.borderCanvas.width, this.borderCanvas.height);
                }
            },

            handleResize: function () {
                if (!this.patternCanvas || !this.borderCanvas) return;

                this.patternCanvas.width = window.innerWidth;
                this.patternCanvas.height = window.innerHeight;
                this.borderCanvas.width = window.innerWidth;
                this.borderCanvas.height = window.innerHeight;

                this.drawPattern();

                setTimeout(() => {
                    this.updateBorders();
                }, 100);
            }
        };
    </script>
</body>

</html>