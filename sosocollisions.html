<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lemmings Game - Stable Collisions</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            border: 2px solid #34495e;
            background-color: #87CEEB;
            margin: 10px;
            max-width: min(95vw, 71.25vh);
            max-height: min(95vh, 63.33vw);
            width: auto;
            height: auto;
            display: block;
        }

        .debug-panel {
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            margin: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
        }
    </style>
</head>

<body>
    <canvas id="terrainCanvas" width="800" height="1200"></canvas>
    <div class="debug-panel" id="debugPanel">Stable Collision System Active</div>

    <script>
        const canvas = document.getElementById('terrainCanvas');
        const ctx = canvas.getContext('2d');
        const debugPanel = document.getElementById('debugPanel');

        // Create off-screen terrain canvas that preserves explosions
        const terrainCanvas = document.createElement('canvas');
        terrainCanvas.width = canvas.width;
        terrainCanvas.height = canvas.height;
        const terrainCtx = terrainCanvas.getContext('2d');

        let numPoints = 45;
        let terrainRatio = 0.4;
        let points = [];
        let entrance = null;
        let exit = null;
        let lemmings = [];
        let lastSpawnTime = 0;
        const SPAWN_INTERVAL = 2000;
        let maxLemmings = 40;
        let lemmingsSpawned = 0;
        let lemmingsSaved = 0;

        // Game state
        let levelTime = 120000;
        let gameStartTime = 0;
        let currentLevel = 1;
        let gameActive = true;

        // Line drawing system - back to simple points arrays
        let isDrawing = false;
        let currentLine = [];
        let drawnLines = [];
        let debugMode = false;

        // Lemming class - simplified and stable
        class Lemming {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.vx = 0.25;
                this.vy = 0;
                this.width = 30;
                this.height = 40;
                this.alive = true;
                this.groundBuffer = 0; // Prevents trembling
            }

            update() {
                if (!this.alive) return;

                const centerX = this.x + this.width / 2;
                const centerY = this.y + this.height / 2;
                const feetY = this.y + this.height;

                // Direct ground check - no buffer system
                const isOnGround = this.isSolid(centerX, feetY + 1);

                // Debug for first penguin
                if (debugMode && lemmings.indexOf(this) === 0) {
                    const pixel = this.getPixelColor(Math.floor(centerX), Math.floor(feetY + 1));
                    const pixelStr = pixel ? `RGB(${pixel[0]},${pixel[1]},${pixel[2]})` : 'null';
                    updateDebug(`P1: pos(${Math.round(this.x)},${Math.round(this.y)}) checking(${Math.round(centerX)},${Math.round(feetY + 1)}) pixel:${pixelStr} solid:${isOnGround}`);
                }

                if (isOnGround) {
                    // On ground - stop falling and try to move
                    this.vy = 0;

                    // Advanced slope/wall detection
                    const moveDistance = this.vx > 0 ? this.width + 2 : -2;
                    const checkX = this.x + moveDistance;
                    const slopeInfo = this.analyzeSlopeAhead(checkX, centerY, feetY);

                    if (slopeInfo.isWall) {
                        // Too steep - turn around
                        this.vx = -this.vx;
                        if (debugMode && lemmings.indexOf(this) === 0) {
                            updateDebug(`P1: Hit wall/steep slope - turned around`);
                        }
                    } else if (slopeInfo.canClimb) {
                        // Gentle slope - step up and move forward
                        this.y -= slopeInfo.stepHeight;
                        this.x += this.vx;
                        if (debugMode && lemmings.indexOf(this) === 0) {
                            updateDebug(`P1: Climbing slope - step up ${slopeInfo.stepHeight}px`);
                        }
                    } else {
                        // Clear path - just move
                        this.x += this.vx;
                    }
                } else {
                    // Not on ground - fall immediately
                    this.vy += 0.4;
                    this.y += this.vy;

                    if (debugMode && lemmings.indexOf(this) === 0) {
                        updateDebug(`P1: FALLING - vy:${this.vy.toFixed(1)}, new y:${Math.round(this.y)}`);
                    }
                }

                // Screen boundaries
                if (this.x <= 0 || this.x >= canvas.width - this.width) {
                    this.vx = -this.vx;
                    this.x = Math.max(0, Math.min(canvas.width - this.width, this.x));
                }

                // Check if reached exit
                if (exit && this.distance(centerX, centerY, exit.x, exit.y) < 60) {
                    this.alive = false;
                    lemmingsSaved++;
                    updateDebug(`Penguin saved! Total: ${lemmingsSaved}/${lemmingsSpawned}`);
                    return;
                }

                // Check if fell off screen
                if (this.y > canvas.height + 100) {
                    this.alive = false;
                    return;
                }
            }

            // Simple, reliable collision detection
            isSolid(x, y) {
                const pixel = this.getPixelColor(Math.floor(x), Math.floor(y));
                if (!pixel) return false;

                const [r, g, b, a] = pixel;

                // Skip transparent pixels
                if (a < 128) return false;

                // EXCLUDE sky blue background explicitly first
                if (r >= 130 && r <= 140 && g >= 200 && g <= 210 && b >= 230 && b <= 240) {
                    return false; // This is definitely sky blue background
                }

                // FIRST - check if we're near spawn points and exclude EVERYTHING in those areas
                const nearEntrance = entrance && Math.abs(x - entrance.x) < 60 && Math.abs(y - entrance.y) < 60;
                const nearExit = exit && Math.abs(x - exit.x) < 60 && Math.abs(y - exit.y) < 60;

                if (nearEntrance || nearExit) {
                    // Near spawn points - only consider brown terrain as solid, ignore everything else
                    if (r >= 80 && r <= 180 && g >= 30 && g <= 100 && b >= 10 && b <= 80) {
                        return true; // Brown terrain is still solid
                    }
                    return false; // Everything else (green circle, red circle, black outline) is non-solid
                }

                // Away from spawn points - normal collision detection

                // Brown terrain
                if (r >= 80 && r <= 180 && g >= 30 && g <= 100 && b >= 10 && b <= 80) {
                    return true;
                }

                // Blue lines (drawn by player) - more permissive but exclude sky blue
                if (b >= 150 && b > r + 50 && b > g + 50) {
                    // High blue value that's significantly higher than red and green
                    // This catches #0066FF (0,102,255) and similar blues
                    // But excludes sky blue (135,206,235) because 235 is NOT > 206+50
                    return true;
                }

                // Green lines (currently being drawn) - more permissive
                if (g >= 150 && g > r + 50 && g > b + 50) {
                    // High green value significantly higher than red and blue
                    return true;
                }

                return false;
            }

            isGreenCircle(r, g, b) {
                return r >= 30 && r <= 80 && g >= 150 && g <= 255 && b >= 30 && b <= 80;
            }

            isRedCircle(r, g, b) {
                return r >= 200 && r <= 255 && g >= 30 && g <= 100 && b >= 30 && b <= 100;
            }

            getPixelColor(x, y) {
                if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) return null;

                try {
                    // Always check the main canvas (which gets redrawn each frame)
                    const mainData = ctx.getImageData(x, y, 1, 1);
                    const mainPixel = mainData.data;

                    // If we got a valid pixel, return it
                    if (mainPixel && mainPixel.length >= 4) {
                        return [mainPixel[0], mainPixel[1], mainPixel[2], mainPixel[3]];
                    }

                    return null;
                } catch (e) {
                    console.error(`Error getting pixel at (${x},${y}):`, e);
                    return null;
                }
            }

            isTerrainPixel(pixel) {
                const [r, g, b] = pixel;
                return r >= 80 && r <= 180 && g >= 30 && g <= 100 && b >= 10 && b <= 80;
            }

            // Analyze slope ahead to determine if penguin can climb it
            analyzeSlopeAhead(checkX, centerY, feetY) {
                const maxClimbHeight = 15; // Maximum pixels penguin can step up
                const forwardDistance = Math.abs(this.vx) * 10; // How far forward we're checking

                // Check if there's any obstruction at body level
                const bodyCollision = this.isSolid(checkX, centerY);

                if (!bodyCollision) {
                    // No obstruction - clear path
                    return { isWall: false, canClimb: false, stepHeight: 0 };
                }

                // There's an obstruction - analyze if it's climbable
                let stepHeight = 0;
                let foundClearance = false;

                // Look upward from feet level to find clearance
                for (let h = 1; h <= maxClimbHeight; h++) {
                    const checkY = feetY - h;

                    // Check if we have clearance at this height
                    const headRoom = !this.isSolid(checkX, checkY - this.height + 5); // Check head clearance
                    const footClear = !this.isSolid(checkX, checkY);

                    if (headRoom && footClear) {
                        stepHeight = h;
                        foundClearance = true;
                        break;
                    }
                }

                if (!foundClearance) {
                    // No clearance found within climb limit - it's a wall
                    return { isWall: true, canClimb: false, stepHeight: 0 };
                }

                // Check slope angle - is rise/run ≤ 1 (45° or less)?
                const slopeRatio = stepHeight / forwardDistance;

                if (slopeRatio <= 1.0) {
                    // Gentle slope - climbable
                    return { isWall: false, canClimb: true, stepHeight: stepHeight };
                } else {
                    // Too steep - treat as wall
                    return { isWall: true, canClimb: false, stepHeight: 0 };
                }
            }

            distance(x1, y1, x2, y2) {
                return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            }

            draw() {
                if (!this.alive) return;

                ctx.save();
                ctx.fillStyle = '#FFA500';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;

                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.strokeRect(this.x, this.y, this.width, this.height);

                // Direction indicator
                ctx.fillStyle = '#000';
                const eyeX = this.vx > 0 ? this.x + this.width - 6 : this.x + 2;
                ctx.fillRect(eyeX, this.y + 5, 4, 4);

                // Debug indicators
                if (debugMode) {
                    // Ground status
                    ctx.fillStyle = this.groundBuffer > 0 ? '#00FF00' : '#FF0000';
                    ctx.fillRect(this.x + this.width / 2 - 2, this.y + this.height + 2, 4, 2);

                    // Movement direction
                    ctx.fillStyle = '#FFFF00';
                    const arrowX = this.vx > 0 ? this.x + this.width : this.x - 4;
                    ctx.fillRect(arrowX, this.y + this.height / 2, 4, 2);
                }

                ctx.restore();
            }
        }

        function updateDebug(message) {
            const timestamp = new Date().toLocaleTimeString();
            const debugMessages = debugPanel.innerHTML.split('<br>').filter(msg => msg.trim() !== '');

            // Keep only recent messages (last 5)
            if (debugMessages.length > 5) {
                debugMessages.splice(1, debugMessages.length - 5);
            }

            debugMessages.push(`${timestamp}: ${message}`);
            debugPanel.innerHTML = debugMessages.join('<br>');

            if (debugMode) {
                console.log(`${timestamp}: ${message}`);
            }
        }

        function generatePoints() {
            points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    isTerrain: Math.random() < terrainRatio
                });
            }
        }

        function distance(x1, y1, x2, y2) {
            return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        }

        let terrainShapes = [];

        function generateTerrain() {
            generatePoints();
            terrainShapes = [];

            // Generate terrain shapes
            for (let i = 0; i < points.length; i++) {
                if (!points[i].isTerrain) continue;

                const centerX = points[i].x;
                const centerY = points[i].y;

                const platformType = Math.random();
                let blobPoints = [];

                if (platformType < 0.4) {
                    const platformWidth = 200 + Math.random() * 300;
                    const platformHeight = 60 + Math.random() * 80;
                    const angle = (Math.random() - 0.5) * 0.5;

                    const numPointsInBlob = 10 + Math.floor(Math.random() * 6);
                    for (let j = 0; j < numPointsInBlob; j++) {
                        const t = j / numPointsInBlob;
                        const localAngle = t * Math.PI * 2;
                        const localRadius = (Math.abs(Math.cos(localAngle)) * platformWidth / 2 +
                            Math.abs(Math.sin(localAngle)) * platformHeight / 2) *
                            (0.8 + Math.random() * 0.4);

                        const x = centerX + Math.cos(localAngle + angle) * localRadius;
                        const y = centerY + Math.sin(localAngle + angle) * localRadius;

                        blobPoints.push({ x, y });
                    }
                } else {
                    const radius = 80 + Math.random() * 60;
                    const numPointsInBlob = 8 + Math.floor(Math.random() * 6);

                    for (let j = 0; j < numPointsInBlob; j++) {
                        const angle = (j / numPointsInBlob) * Math.PI * 2;
                        const r = radius * (0.7 + Math.random() * 0.6);
                        const x = centerX + Math.cos(angle) * r;
                        const y = centerY + Math.sin(angle) * r;

                        blobPoints.push({ x, y });
                    }
                }

                if (blobPoints.length >= 3) {
                    terrainShapes.push(blobPoints);
                }
            }

            drawTerrainOnly();
            findSpawnPoints();
            drawStaticTerrain();
        }

        function drawTerrainOnly() {
            // Clear terrain canvas
            terrainCtx.fillStyle = '#87CEEB';
            terrainCtx.fillRect(0, 0, terrainCanvas.width, terrainCanvas.height);

            // Draw terrain
            terrainCtx.fillStyle = '#8B4513';
            terrainCtx.strokeStyle = '#654321';
            terrainCtx.lineWidth = 4;

            terrainShapes.forEach(blobPoints => {
                terrainCtx.beginPath();
                terrainCtx.moveTo(blobPoints[0].x, blobPoints[0].y);

                for (let j = 1; j < blobPoints.length; j++) {
                    const current = blobPoints[j];
                    const next = blobPoints[(j + 1) % blobPoints.length];

                    const cpX = current.x + (next.x - current.x) * 0.5;
                    const cpY = current.y + (next.y - current.y) * 0.5;

                    terrainCtx.quadraticCurveTo(current.x, current.y, cpX, cpY);
                }

                terrainCtx.quadraticCurveTo(
                    blobPoints[blobPoints.length - 1].x,
                    blobPoints[blobPoints.length - 1].y,
                    blobPoints[0].x,
                    blobPoints[0].y
                );

                terrainCtx.fill();
                terrainCtx.stroke();
            });
        }

        function drawStaticTerrain() {
            // Clear main canvas
            ctx.fillStyle = '#87CEEB';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Copy terrain canvas to main canvas
            ctx.drawImage(terrainCanvas, 0, 0);

            // Draw spawn points
            drawSpawnPoints();
        }

        function isTerrainAt(x, y) {
            if (x < 0 || x >= terrainCanvas.width || y < 0 || y >= terrainCanvas.height) return false;

            try {
                const imageData = terrainCtx.getImageData(x, y, 1, 1);
                const pixel = imageData.data;
                return (pixel[0] >= 80 && pixel[0] <= 180 && pixel[1] >= 30 && pixel[1] <= 100 && pixel[2] >= 10 && pixel[2] <= 80);
            } catch (e) {
                return false;
            }
        }

        function findSpawnPoints() {
            const surfacePoints = [];
            const scanStep = 30;

            for (let x = 80; x < canvas.width - 80; x += scanStep) {
                for (let y = 100; y < canvas.height - 100; y += scanStep) {
                    if (isTerrainAt(x, y)) {
                        const hasSpaceAbove = !isTerrainAt(x, y - 50) && !isTerrainAt(x, y - 35);

                        if (hasSpaceAbove) {
                            const leftOk = isTerrainAt(x - scanStep, y) || isTerrainAt(x - scanStep, y + 12);
                            const rightOk = isTerrainAt(x + scanStep, y) || isTerrainAt(x + scanStep, y + 12);

                            if (leftOk && rightOk) {
                                surfacePoints.push({ x, y });
                            }
                        }
                    }
                }
            }

            if (surfacePoints.length >= 2) {
                surfacePoints.sort((a, b) => a.y - b.y);

                const upperSurfaces = surfacePoints.filter(p => p.y < canvas.height * 0.6);
                const entranceSurface = upperSurfaces.length > 0 ?
                    upperSurfaces[Math.floor(Math.random() * Math.min(3, upperSurfaces.length))] :
                    surfacePoints[0];

                entrance = { x: entranceSurface.x, y: entranceSurface.y - 60 };

                let validExits = surfacePoints.filter(p =>
                    distance(p.x, p.y, entrance.x, entrance.y) > 300
                );

                if (validExits.length === 0) {
                    validExits = surfacePoints.filter(p =>
                        distance(p.x, p.y, entrance.x, entrance.y) > 200
                    );
                }

                if (validExits.length > 0) {
                    const exitSurface = validExits[Math.floor(Math.random() * validExits.length)];
                    exit = { x: exitSurface.x, y: exitSurface.y - 60 };
                } else {
                    exit = { x: surfacePoints[surfacePoints.length - 1].x, y: surfacePoints[surfacePoints.length - 1].y - 60 };
                }
            } else {
                // Fallback
                const entranceY = 200 + Math.random() * 200;
                const exitY = canvas.height - 300 + Math.random() * 150;

                entrance = { x: 160, y: entranceY - 50 };
                exit = { x: canvas.width - 160, y: exitY - 50 };
            }
        }

        function drawSpawnPoints() {
            if (entrance) {
                ctx.fillStyle = '#32CD32';
                ctx.beginPath();
                ctx.arc(entrance.x, entrance.y, 45, 0, 2 * Math.PI);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.stroke();
            }

            if (exit) {
                ctx.fillStyle = '#FF4444';
                ctx.beginPath();
                ctx.arc(exit.x, exit.y, 45, 0, 2 * Math.PI);
                ctx.fill();

                ctx.strokeStyle = '#000';
                ctx.lineWidth = 4;
                ctx.stroke();
            }
        }

        // Mouse coordinate helper
        function getMousePos(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (event.clientX - rect.left) * scaleX,
                y: (event.clientY - rect.top) * scaleY
            };
        }

        // Line drawing events - with debugging
        canvas.addEventListener('mousedown', function (event) {
            const pos = getMousePos(event);
            isDrawing = true;
            currentLine = [pos];
            updateDebug(`Mouse down at (${Math.round(pos.x)}, ${Math.round(pos.y)}) - starting line`);
        });

        canvas.addEventListener('mousemove', function (event) {
            if (!isDrawing) return;

            const pos = getMousePos(event);
            currentLine.push(pos);

            // Debug every 10th point to avoid spam
            if (currentLine.length % 10 === 0) {
                updateDebug(`Drawing line - ${currentLine.length} points`);
            }
        });

        canvas.addEventListener('mouseup', function (event) {
            if (!isDrawing) return;

            isDrawing = false;

            updateDebug(`Mouse up - line has ${currentLine.length} points`);

            if (currentLine.length > 1) {
                // Check for intersections with existing lines
                const intersections = findIntersections(currentLine, drawnLines);

                if (intersections.length > 0) {
                    // Lines intersected - create explosions
                    intersections.forEach(intersection => {
                        const totalLength = getLineLength(currentLine) + getLineLength(intersection.intersectingLine);
                        createExplosion(intersection.x, intersection.y, totalLength);

                        // Remove the intersecting line
                        const lineIndex = drawnLines.indexOf(intersection.intersectingLine);
                        if (lineIndex > -1) {
                            drawnLines.splice(lineIndex, 1);
                        }
                    });

                    updateDebug(`Line intersection - explosion created! ${drawnLines.length} lines remaining`);
                } else {
                    // No intersections - add line
                    drawnLines.push([...currentLine]);
                    updateDebug(`Line added successfully - ${drawnLines.length} total lines`);
                }
            } else {
                updateDebug(`Line too short (${currentLine.length} points) - not added`);
            }

            currentLine = [];
        });

        function getLineLength(line) {
            if (line.length < 2) return 0;

            let totalLength = 0;
            for (let i = 1; i < line.length; i++) {
                const dx = line[i].x - line[i - 1].x;
                const dy = line[i].y - line[i - 1].y;
                totalLength += Math.sqrt(dx * dx + dy * dy);
            }
            return totalLength;
        }

        function findIntersections(newLine, existingLines) {
            const intersections = [];

            for (let existingLine of existingLines) {
                for (let i = 0; i < newLine.length - 1; i++) {
                    const newSeg = { start: newLine[i], end: newLine[i + 1] };

                    for (let j = 0; j < existingLine.length - 1; j++) {
                        const existingSeg = { start: existingLine[j], end: existingLine[j + 1] };

                        const intersection = getLineIntersection(newSeg, existingSeg);
                        if (intersection) {
                            intersections.push({
                                x: intersection.x,
                                y: intersection.y,
                                intersectingLine: existingLine
                            });
                        }
                    }
                }
            }

            return intersections;
        }

        function getLineIntersection(line1, line2) {
            const x1 = line1.start.x, y1 = line1.start.y;
            const x2 = line1.end.x, y2 = line1.end.y;
            const x3 = line2.start.x, y3 = line2.start.y;
            const x4 = line2.end.x, y4 = line2.end.y;

            const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
            if (Math.abs(denominator) < 0.0001) return null;

            const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
            const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;

            if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {
                return {
                    x: x1 + t * (x2 - x1),
                    y: y1 + t * (y2 - y1)
                };
            }

            return null;
        }

        function createExplosion(x, y, totalLineLength) {
            // Apply explosion to terrain canvas - make sure it's properly clearing
            terrainCtx.save();
            terrainCtx.globalCompositeOperation = 'destination-out';
            terrainCtx.fillStyle = 'rgba(0, 0, 0, 1)';

            const radius = Math.max(40, totalLineLength * 0.1); // Slightly bigger explosions
            const numPoints = 12 + Math.floor(Math.random() * 8);
            const explosionPoints = [];

            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * Math.PI * 2;
                const radiusVar = 0.6 + Math.random() * 0.8;
                const r = radius * radiusVar;

                explosionPoints.push({
                    x: x + Math.cos(angle) * r,
                    y: y + Math.sin(angle) * r
                });
            }

            if (explosionPoints.length >= 3) {
                terrainCtx.beginPath();
                terrainCtx.moveTo(explosionPoints[0].x, explosionPoints[0].y);

                for (let i = 1; i < explosionPoints.length; i++) {
                    const current = explosionPoints[i];
                    const next = explosionPoints[(i + 1) % explosionPoints.length];

                    const cpX = current.x + (next.x - current.x) * 0.5;
                    const cpY = current.y + (next.y - current.y) * 0.5;

                    terrainCtx.quadraticCurveTo(current.x, current.y, cpX, cpY);
                }

                terrainCtx.quadraticCurveTo(
                    explosionPoints[explosionPoints.length - 1].x,
                    explosionPoints[explosionPoints.length - 1].y,
                    explosionPoints[0].x,
                    explosionPoints[0].y
                );

                terrainCtx.fill();

                // Double-clear with a simple circle to ensure complete removal
                terrainCtx.beginPath();
                terrainCtx.arc(x, y, radius * 0.8, 0, 2 * Math.PI);
                terrainCtx.fill();
            }

            terrainCtx.restore();

            // Force any penguins in the explosion area to lose their ground buffer
            lemmings.forEach(lemming => {
                const lemmingCenterX = lemming.x + lemming.width / 2;
                const lemmingCenterY = lemming.y + lemming.height / 2;
                const distanceToExplosion = Math.sqrt((lemmingCenterX - x) ** 2 + (lemmingCenterY - y) ** 2);

                if (distanceToExplosion < radius * 1.2) {
                    // Penguin is near explosion - force ground check reset
                    lemming.groundBuffer = 0;
                    updateDebug(`Penguin near explosion - ground buffer reset`);
                }
            });

            updateDebug(`Explosion created at (${Math.round(x)}, ${Math.round(y)}) with radius ${Math.round(radius)}`);
        }

        function spawnLemming() {
            if (entrance && lemmingsSpawned < maxLemmings) {
                // Spawn higher to ensure clean drop
                const lemming = new Lemming(entrance.x - 15, entrance.y - 50);
                lemmings.push(lemming);
                lemmingsSpawned++;

                updateDebug(`Spawned penguin ${lemmingsSpawned}/${maxLemmings}`);
            }
        }

        function drawGame() {
            // Redraw static terrain
            drawStaticTerrain();

            // Draw current line being drawn - make it more obvious
            if (isDrawing && currentLine.length > 0) {
                ctx.save();
                ctx.strokeStyle = '#00FF00';
                ctx.lineWidth = 8; // Thicker for visibility
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 0.9;

                if (currentLine.length === 1) {
                    // Just started - draw a dot
                    ctx.beginPath();
                    ctx.arc(currentLine[0].x, currentLine[0].y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                } else {
                    // Draw the line
                    ctx.beginPath();
                    ctx.moveTo(currentLine[0].x, currentLine[0].y);
                    for (let i = 1; i < currentLine.length; i++) {
                        ctx.lineTo(currentLine[i].x, currentLine[i].y);
                    }
                    ctx.stroke();
                }
                ctx.restore();
            }

            // Draw completed lines - make them more obvious too
            drawnLines.forEach((line, index) => {
                if (line.length < 2) return;

                ctx.save();
                ctx.strokeStyle = '#0066FF';
                ctx.lineWidth = 8; // Thicker for visibility
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.globalAlpha = 0.9;

                ctx.beginPath();
                ctx.moveTo(line[0].x, line[0].y);
                for (let i = 1; i < line.length; i++) {
                    ctx.lineTo(line[i].x, line[i].y);
                }
                ctx.stroke();
                ctx.restore();
            });

            // Draw lemmings
            lemmings.forEach(lemming => lemming.draw());

            // Draw UI
            drawUI();

            // Draw drawing status indicator
            if (isDrawing) {
                ctx.save();
                ctx.fillStyle = '#00FF00';
                ctx.font = 'bold 20px Arial';
                ctx.textAlign = 'left';
                ctx.fillText('DRAWING...', 20, canvas.height - 20);
                ctx.restore();
            }
        }

        function drawUI() {
            ctx.save();
            ctx.fillStyle = '#FFFFFF';
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'right';

            // Timer
            const remainingTime = Math.max(0, levelTime - (Date.now() - gameStartTime));
            const minutes = Math.floor(remainingTime / 60000);
            const seconds = Math.floor((remainingTime % 60000) / 1000);
            const timeText = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            ctx.strokeText(timeText, canvas.width - 20, 40);
            ctx.fillText(timeText, canvas.width - 20, 40);

            // Level and penguin count
            ctx.textAlign = 'left';
            ctx.font = 'bold 20px Arial';
            const levelText = `Level ${currentLevel}`;
            const penguinText = `Penguins: ${lemmingsSaved}/${lemmingsSpawned}`;

            ctx.strokeText(levelText, 20, 40);
            ctx.fillText(levelText, 20, 40);

            ctx.strokeText(penguinText, 20, 70);
            ctx.fillText(penguinText, 20, 70);

            ctx.restore();
        }

        function nextLevel() {
            currentLevel++;
            const penguinsForNextLevel = lemmingsSaved;

            updateDebug(`Level ${currentLevel}: Saved ${penguinsForNextLevel} penguins`);

            // Reset for next level
            lemmings = [];
            drawnLines = [];
            lemmingsSpawned = 0;
            lemmingsSaved = 0;
            maxLemmings = penguinsForNextLevel;

            // Generate new terrain
            generateTerrain();

            // Reset timer
            gameStartTime = Date.now();
            gameActive = true;
            requestAnimationFrame(gameLoop);
        }

        function gameLoop(currentTime) {
            if (!gameActive) return;

            // Check if time is up
            const remainingTime = levelTime - (currentTime - gameStartTime);
            if (remainingTime <= 0) {
                if (lemmingsSaved > 0) {
                    setTimeout(() => nextLevel(), 1000);
                    gameActive = false;
                    return;
                } else {
                    setTimeout(() => {
                        ctx.save();
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        ctx.fillStyle = '#FFFFFF';
                        ctx.font = 'bold 48px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('Time Up!', canvas.width / 2, canvas.height / 2);
                        ctx.font = 'bold 24px Arial';
                        ctx.fillText(`Game Over - Level ${currentLevel}`, canvas.width / 2, canvas.height / 2 + 60);
                        ctx.restore();
                    }, 1000);

                    gameActive = false;
                    return;
                }
            }

            // Spawn penguins
            if (currentTime - lastSpawnTime > SPAWN_INTERVAL) {
                spawnLemming();
                lastSpawnTime = currentTime;
            }

            // Update lemmings
            lemmings.forEach(lemming => lemming.update());

            // Remove dead lemmings
            lemmings = lemmings.filter(lemming => lemming.alive);

            // Draw everything
            drawGame();

            if (gameActive) {
                requestAnimationFrame(gameLoop);
            }
        }

        // Debug toggle
        document.addEventListener('keydown', function (event) {
            if (event.key === 'd' || event.key === 'D') {
                debugMode = !debugMode;
                updateDebug(`Debug mode: ${debugMode ? 'ON' : 'OFF'}`);
            }
        });

        // Initialize game
        generateTerrain();
        gameStartTime = Date.now();
        updateDebug("Stable collision system initialized - Press 'D' for debug mode");
        requestAnimationFrame(gameLoop);
    </script>
</body>

</html>